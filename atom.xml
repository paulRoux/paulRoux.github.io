<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shirsen’s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://roux.top/"/>
  <updated>2019-04-29T04:08:27.404Z</updated>
  <id>http://roux.top/</id>
  
  <author>
    <name>Shirsen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows10更新系统导致控制台和部分软件中文乱码</title>
    <link href="http://roux.top/2019/04/29/Windows10%E8%BD%AF%E4%BB%B6%E4%B9%B1%E7%A0%81/"/>
    <id>http://roux.top/2019/04/29/Windows10软件乱码/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T04:08:27.404Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>昨天更新windows10家庭版的1803版本到最新的版本，更新完成后发现控制台和部分软件出现了乱码的现象，网上找了不少的解决办法，最终自己完全解决了！</li></ul><a id="more"></a><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li><p>首先，定位到 <code>C:\Users\用户\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Windows PowerShell</code>，鼠标右击windows powershell以管理员运行，复制粘贴以下命令运行， <code>Get-AppxPackage -AllUsers| Foreach {Add-AppxPackage -DisableDevelopmentMode -Register “$($_.InstallLocation)\AppXManifest.xml”}</code> 或者 <code>Get-AppxPackage | % { Add-AppxPackage -DisableDevelopmentMode -Register &quot;$($_.InstallLocation)\AppxManifest.xml&quot; -verbose }</code></p></li><li><p>上个阶段会出现很多的错误，第一个命令执行完了可以执行第二个的。完成后会解决部分的软件乱码，但是还有很多无法解决。</p></li><li><p>接下来，定位到 <code>设置-&gt;时间和语言-&gt;区域和语言-&gt;管理语言设置-&gt;管理-&gt;更改系统区域设置</code>在这里我选择了<code>中文简体-新加坡</code>，然后重启。</p></li><li><p>重启后会发现乱码消失了，然后将新加坡换回中国就好了(也可以不换)。</p></li><li><p>如果还有问题，比如说我有一个脚本是爬取菜鸟教程的设计模式的文章，爬取文章title的时候出现控制台乱码，但是爬取其他比如百度的就正常，这可能是网站的编码压缩原因(那就需要你自己进行解压缩)。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;昨天更新windows10家庭版的1803版本到最新的版本，更新完成后发现控制台和部分软件出现了乱码的现象，网上找了不少的解决办法，最终自己完全解决了！&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="Windwos" scheme="http://roux.top/tags/Windwos/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件</title>
    <link href="http://roux.top/2019/04/27/Chrome%E6%8F%92%E4%BB%B6/"/>
    <id>http://roux.top/2019/04/27/Chrome插件/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-27T05:01:41.063Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>关于Chrome上一些好用的插件(需要科学上网)</li></ul><a id="more"></a><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul><li><p>AdGuard广告拦截器</p><ul><li>看名字就知道是拦截各大网站广告的插件。这个插件分为免费和付费版，个人用的话免费版是足够。它的拦截率还是很不错的，而且里面有各种拦截的规则，支持自定义和自己拦截元素，更新规则的频率还可以。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/adguard-adblocker/bgnkhhnnamicmpeenaelnjfhikgbkllg?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/adguard-adblocker/bgnkhhnnamicmpeenaelnjfhikgbkllg?utm_source=chrome-ntp-icon</a></li></ul></li><li><p>Infinity 新标签页</p><ul><li>提供新的标签页的插件。这个插件可以自定义新标签页的搜索引擎、壁纸，以及一些好用的工具，避免每次需要打开一些常用的网页的时候还要搜索打开。它带有云端备份和同步的功能，还带有工具商店可以供大家选择。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg</a></li></ul></li><li><p>Stylus</p><ul><li>Stylus 是一个调整网页外观的用户样式管理器。这个插件可以为许多知名的网站提供精美的主题和皮肤，有相关的主题和皮肤网站供大家下载。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne</a></li><li>主题库：<a href="https://userstyles.org/" target="_blank" rel="noopener">https://userstyles.org/</a></li></ul></li><li><p>LastPass: Free Password Manager</p><ul><li>一款密码管理器。这个插件可以加密保存你的密码(听说加密算法很复杂)，方便你在任何时候浏览网页一键登录，并且可以避免密码保存在本地的风险(我还是比较相信云端的)，而且可以导入你的chrome保存的密码与管理密码。</li><li>URl：<a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd</a></li></ul></li><li><p>Tampermonkey BETA</p><ul><li>一款加载网页脚本的插件。这个插件可以用来加载一些自定义的脚本，用来美化浏览器并实现一些你想要的功能。它提供了一个脚本网站方便用户下载和发布相关的脚本。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/tampermonkey-beta/gcalenpjmijncebpfijmoaglllgpjagf" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/tampermonkey-beta/gcalenpjmijncebpfijmoaglllgpjagf</a></li><li>脚本库：<a href="https://greasyfork.org/zh-CN/" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/</a></li></ul></li><li><p>简 悦</p><ul><li>一款提供阅读的插件。这个插件将网页进行简化，提供一个合适阅读的排版。用户可以进行相关的偏好设置(选项还挺多，并且有多种模式)，并且提供了相关的论坛供用户交流。</li><li>URL：<a href="http://ksria.com/simpread/" target="_blank" rel="noopener">http://ksria.com/simpread/</a></li></ul></li><li><p>Google 翻译</p><ul><li>这个插件不用说了。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb</a></li></ul></li><li><p>有道词典Chrome划词插件</p><ul><li>这个插件主要就是方便大家看英文页面。支持查词、长句翻译。个人感觉翻译的质量还可以。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8chrome%E5%88%92%E8%AF%8D%E6%8F%92%E4%BB%B6/eopjamdnofihpioajgfdikhhbobonhbb" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8chrome%E5%88%92%E8%AF%8D%E6%8F%92%E4%BB%B6/eopjamdnofihpioajgfdikhhbobonhbb</a></li></ul></li><li><p>沙拉查词-聚合词典划词翻译</p><ul><li>这个插件和有道功能相似。但是这个聚合了好几个翻译方案，并且使用起来也很方便。可以搭配有道进行使用。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg/related" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg/related</a></li></ul></li><li><p>分享到微信</p><ul><li>这个插件主要的目的就是让大家可以把网页分享到微信</li><li>URL: <a href="https://chrome.google.com/webstore/detail/%E5%88%86%E4%BA%AB%E5%88%B0%E5%BE%AE%E4%BF%A1/gjmlaljbhjlbmdgdglcnilnfjeignbij" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/%E5%88%86%E4%BA%AB%E5%88%B0%E5%BE%AE%E4%BF%A1/gjmlaljbhjlbmdgdglcnilnfjeignbij</a></li></ul></li><li><p>高效网页截图编辑插件</p><ul><li>一款网页截图插件。可以像画图软件那样用直线、箭头、圆圈、文字做出标识。并可以方便的通过链接或者附件分享。目前使用的是Snipaste所以这款插件没有使用了。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/explain-and-send-screensh/mdddabjhelpilpnpgondfmehhcplpiin" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/explain-and-send-screensh/mdddabjhelpilpnpgondfmehhcplpiin</a></li></ul></li><li><p>Fatkun图片批量下载</p><ul><li>一款下载图片的插件。很不错的插件，不过我用的场合不多。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf</a></li></ul></li><li><p>OneTab</p><ul><li>一款节约Chrome内存减轻标签页混乱的插件。如果发现自己有太多的标签页时，单击OneTab图标，将所有标签页转换成一个列表。当需要再次访问这些标签页时，可以单独或全部恢复就好了。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall</a></li></ul></li><li><p>Octotree</p><ul><li>一款显示github的仓库代码树的插件。每次查看github仓库的代码的时候非常麻烦，这款插件简化了许多的操作。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnag" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnag</a></li></ul></li><li><p>Vimium</p><ul><li>一款让你的浏览器像操作Vim一样的插件。如果你是Vim爱好者，或者你喜欢简单的操作方式，你都可以尝试这款插件。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb</a></li></ul></li><li><p>IDM Integration Module</p><ul><li>一款下载插件，需要配合IDM客户端来使用(收费，但是不贵)。这个插件可以监听各大浏览器，代替浏览器自己的下载器，而且它支持多种格式和多线程下载，配合一些脚本，基本可以下载所有的东西。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek</a></li></ul></li><li><p>Proxy SwitchyOmega</p><ul><li>一款Chrome的代理切换插件。目前我主要在Ubuntu下科学上网使用，Windows下使用酸酸乳就好了。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif</a></li></ul></li><li><p>WEB前端助手(FeHelper)</p><ul><li>前端开发和爬虫使用。内置了很多的小工具，再也不用费事了。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad</a></li></ul></li><li><p>XPath Helper</p><ul><li>爬虫使用。写xpath表达式进行预览。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl</a></li></ul></li><li><p>User-Agent Switcher</p><ul><li>爬虫使用。用来切换UA，查看网页的情况。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/user-agent-switcher/clddifkhlkcojbojppdojfeeikdkgiae" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/user-agent-switcher/clddifkhlkcojbojppdojfeeikdkgiae</a></li></ul></li><li><p>类似的网站 - 发现相关网站</p><ul><li>主要功能就是发现类似的网站。尤其是在我们找资源的时候，这个网站没有，但是往往在另外一个存在。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/similar-sites-discover-re/necpbmbhhdiplmfhmjicabdeighkndkn" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/similar-sites-discover-re/necpbmbhhdiplmfhmjicabdeighkndkn</a></li></ul></li><li><p>Video Speed Controller</p><ul><li>一款控制HTML5视频播放速度的插件。对于我这种经常需要看视频的人，往往一些视频需要加速，但是好多网站不提供倍速或者最多2倍速，很浪费时间。这款插件可以最高提供16倍速，配合一些HTML5播放的脚本，不用太爽。</li><li>URL：<a href="https://chrome.google.com/webstore/detail/video-speed-controller/nffaoalbilbmmfgbnbgppjihopabppdk" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/video-speed-controller/nffaoalbilbmmfgbnbgppjihopabppdk</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;关于Chrome上一些好用的插件(需要科学上网)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="Chrome" scheme="http://roux.top/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>随笔2019-04-26</title>
    <link href="http://roux.top/2019/04/26/%E9%9A%8F%E7%AC%942019-04-26/"/>
    <id>http://roux.top/2019/04/26/随笔2019-04-26/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-04-26T15:09:33.211Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>关于互联网的一些瞎扯。</li></ul><a id="more"></a><h4 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h4><p>&emsp;&emsp;去年秋招结束后，各大公司就相继出现裁员的情况，更甚的是许多大公司也有出现毁约应届生的情况。看到这些新闻，我知道一些变化发生了。首先，互联网的红利已经没有了，可以看到今年春招的要求变得更高了，公司内部也开始裁员并消化以前抢占市场所招来的人才，也不会出现以前随便培训一下就能找到ok的工作的情况。其次，随着中国互联网的发展，门槛是越来越低，市场的一般需求也趋于饱和，大家都开始提高招聘标准。<br>&emsp;&emsp;这些情况的出现，也反映在教育和资源方面：转行到计算机的人每年都在增长，去年和今年达到高峰，明年可能会更高、读研的人也越来越多，并且大多数都是想考一个和计算机相关的专业导致今年各大优秀院校的计算机院和软院全部爆满、网上的资源也唾手可得，网课及相关资料一大堆。<br>&emsp;&emsp;我想，后面可能会出现更激烈的优胜劣汰，并且一时半会不会发生大的改变。这个时候应对的方法就是努力的提升自我，掌握核心技术。<br>&emsp;&emsp;看大佬们的文章看的多了，感觉自己也会瞎扯了，哈哈！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;关于互联网的一些瞎扯。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="生活" scheme="http://roux.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://roux.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>windows10命令</title>
    <link href="http://roux.top/2019/04/20/windows10%E5%91%BD%E4%BB%A4/"/>
    <id>http://roux.top/2019/04/20/windows10命令/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-26T12:58:51.386Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>记录<code>window10</code>CMD下面的一些命令</li></ul><a id="more"></a><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">1. calc：启动计算器</span><br><span class="line"></span><br><span class="line">2. appwiz.cpl：程序和功能</span><br><span class="line"></span><br><span class="line">3. certmgr.msc：证书管理实用程序</span><br><span class="line"></span><br><span class="line">   4. charmap：启动字符映射表</span><br><span class="line"></span><br><span class="line">   5. chkdsk.exe：Chkdsk磁盘检查(管理员身份运行命令提示符)</span><br><span class="line"></span><br><span class="line">   6. cleanmgr: 打开磁盘清理工具</span><br><span class="line"></span><br><span class="line">   7. cliconfg：SQL SERVER 客户端网络实用工具</span><br><span class="line"></span><br><span class="line">   8. cmstp：连接管理器配置文件安装程序</span><br><span class="line"></span><br><span class="line">   9. cmd.exe：CMD命令提示符</span><br><span class="line"></span><br><span class="line">   10. 自动关机命令</span><br><span class="line"></span><br><span class="line">       Shutdown -s -t 600：表示600秒后自动关机</span><br><span class="line">       </span><br><span class="line">       Shutdown -r -t 600：表示600秒后自动重启</span><br><span class="line"></span><br><span class="line">       shutdown -a ：可取消定时关机</span><br><span class="line"></span><br><span class="line">       rundll32 user32.dll,LockWorkStation：表示锁定计算机</span><br><span class="line"></span><br><span class="line">   11. colorcpl：颜色管理，配置显示器和打印机等中的色彩</span><br><span class="line"></span><br><span class="line">   12. CompMgmtLauncher：计算机管理</span><br><span class="line"></span><br><span class="line">   13. compmgmt.msc：计算机管理</span><br><span class="line"></span><br><span class="line">   14. credwiz：备份或还原储存的用户名和密码</span><br><span class="line"></span><br><span class="line">   15. comexp.msc：打开系统组件服务</span><br><span class="line"></span><br><span class="line">   16. control：控制面版</span><br><span class="line"></span><br><span class="line">   17. dcomcnfg：打开系统组件服务</span><br><span class="line"></span><br><span class="line">   18. Dccw：显示颜色校准</span><br><span class="line"></span><br><span class="line">   19. devmgmt.msc：设备管理器</span><br><span class="line"></span><br><span class="line">   20. desk.cpl：屏幕分辨率</span><br><span class="line"></span><br><span class="line">   21. dfrgui：优化驱动器 Windows 7→dfrg.msc：磁盘碎片整理程序</span><br><span class="line"></span><br><span class="line">   22. dialer：电话拨号程序</span><br><span class="line"></span><br><span class="line">   23. diskmgmt.msc：磁盘管理</span><br><span class="line"></span><br><span class="line">   24. dvdplay：DVD播放器</span><br><span class="line"></span><br><span class="line">   25. dxdiag：检查DirectX信息</span><br><span class="line"></span><br><span class="line">   26. eudcedit：造字程序</span><br><span class="line"></span><br><span class="line">   27. eventvwr：事件查看器</span><br><span class="line"></span><br><span class="line">   28. explorer：打开资源管理器</span><br><span class="line"></span><br><span class="line">   29. Firewall.cpl：Windows防火墙</span><br><span class="line"></span><br><span class="line">   30. FXSCOVER：传真封面编辑器</span><br><span class="line"></span><br><span class="line">   31. fsmgmt.msc：共享文件夹管理器</span><br><span class="line"></span><br><span class="line">   32. gpedit.msc：组策略</span><br><span class="line"></span><br><span class="line">   33. hdwwiz.cpl：设备管理器</span><br><span class="line"></span><br><span class="line">   34. inetcpl.cpl：Internet属性</span><br><span class="line"></span><br><span class="line">   35. intl.cpl：区域</span><br><span class="line"></span><br><span class="line">   36. iexpress：木马捆绑工具，系统自带</span><br><span class="line"></span><br><span class="line">   37. joy.cpl：游戏控制器</span><br><span class="line"></span><br><span class="line">   38. logoff：注销命令</span><br><span class="line"></span><br><span class="line">   39. lusrmgr.msc：本地用户和组</span><br><span class="line"></span><br><span class="line">   40. lpksetup：语言包安装/删除向导，安装向导会提示下载语言包</span><br><span class="line"></span><br><span class="line">   41. lusrmgr.msc：本机用户和组</span><br><span class="line"></span><br><span class="line">   42. main.cpl：鼠标属性</span><br><span class="line"></span><br><span class="line">   43. mmsys.cpl：声音</span><br><span class="line"></span><br><span class="line">   44. magnify：放大镜实用程序</span><br><span class="line"></span><br><span class="line">   45. mem.exe：显示内存使用情况(如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe&gt;d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。)</span><br><span class="line"></span><br><span class="line">   46. MdSched:Windows内存诊断程序</span><br><span class="line"></span><br><span class="line">   47. mmc：打开控制台</span><br><span class="line"></span><br><span class="line">   48. mobsync：同步命令</span><br><span class="line"></span><br><span class="line">   49. mplayer2：简易widnows media player</span><br><span class="line"></span><br><span class="line">   50. Msconfig.exe：系统配置实用程序</span><br><span class="line"></span><br><span class="line">   51. msdt：微软支持诊断工具</span><br><span class="line"></span><br><span class="line">   52. msinfo32：系统信息</span><br><span class="line"></span><br><span class="line">   53. mspaint：画图</span><br><span class="line"></span><br><span class="line">   54. Msra：Windows远程协助</span><br><span class="line"></span><br><span class="line">   55. mstsc：远程桌面连接</span><br><span class="line"></span><br><span class="line">   56. NAPCLCFG.MSC：客户端配置</span><br><span class="line"></span><br><span class="line">   57. ncpa.cpl：网络连接</span><br><span class="line"></span><br><span class="line">   58. narrator：屏幕“讲述人”</span><br><span class="line"></span><br><span class="line">   59. Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项</span><br><span class="line"></span><br><span class="line">   60. netstat : an(TC)命令检查接口</span><br><span class="line"></span><br><span class="line">   61. notepad：打开记事本</span><br><span class="line"></span><br><span class="line">   62. Nslookup：IP地址侦测器</span><br><span class="line"></span><br><span class="line">   63. odbcad32：ODBC数据源管理器</span><br><span class="line"></span><br><span class="line">   64. OptionalFeatures：打开“打开或关闭Windows功能”对话框</span><br><span class="line"></span><br><span class="line">   65. osk：打开屏幕键盘</span><br><span class="line"></span><br><span class="line">   66. perfmon.msc：计算机性能监测器</span><br><span class="line"></span><br><span class="line">   67. perfmon：计算机性能监测器</span><br><span class="line"></span><br><span class="line">   68. PowerShell：提供强大远程处理能力</span><br><span class="line"></span><br><span class="line">   69. printmanagement.msc：打印管理</span><br><span class="line"></span><br><span class="line">   70. powercfg.cpl：电源选项</span><br><span class="line"></span><br><span class="line">   71. psr：问题步骤记录器</span><br><span class="line"></span><br><span class="line">   72. Rasphone：网络连接</span><br><span class="line"></span><br><span class="line">   73. Recdisc：创建系统修复光盘</span><br><span class="line"></span><br><span class="line">   74. Resmon：资源监视器</span><br><span class="line"></span><br><span class="line">   75. Rstrui：系统还原</span><br><span class="line"></span><br><span class="line">   76. regedit.exe：注册表</span><br><span class="line"></span><br><span class="line">   77. regedt32：注册表编辑器</span><br><span class="line"></span><br><span class="line">   78. rsop.msc：组策略结果集</span><br><span class="line"></span><br><span class="line">   79. sdclt：备份状态与配置，就是查看系统是否已备份</span><br><span class="line"></span><br><span class="line">   80. secpol.msc：本地安全策略</span><br><span class="line"></span><br><span class="line">   81. services.msc：本地服务设置</span><br><span class="line"></span><br><span class="line">   82. sfc /scannow：扫描错误并复原/windows文件保护</span><br><span class="line"></span><br><span class="line">   83. sfc.exe：系统文件检查器</span><br><span class="line"></span><br><span class="line">   84. shrpubw：创建共享文件夹</span><br><span class="line"></span><br><span class="line">   85. sigverif：文件签名验证程序</span><br><span class="line"></span><br><span class="line">   86. slui：Windows激活，查看系统激活信息</span><br><span class="line"></span><br><span class="line">   87. slmgr.vbs -dlv ：显示详细的许可证信息</span><br><span class="line"></span><br><span class="line">   88. snippingtool：截图工具，支持无规则截图</span><br><span class="line"></span><br><span class="line">   89. soundrecorder：录音机，没有录音时间的限制</span><br><span class="line"></span><br><span class="line">   90. StikyNot：便笺</span><br><span class="line"></span><br><span class="line">   91. sysdm.cpl：系统属性</span><br><span class="line"></span><br><span class="line">   92. sysedit：系统配置编辑器</span><br><span class="line"></span><br><span class="line">   93. syskey：系统加密，一旦加密就不能解开，保护系统的双重密码</span><br><span class="line"></span><br><span class="line">   94. taskmgr：任务管理器(旧版)</span><br><span class="line"></span><br><span class="line">   95. TM任务管理器(新版)</span><br><span class="line"></span><br><span class="line">   96. taskschd.msc：任务计划程序</span><br><span class="line"></span><br><span class="line">   97. timedate.cpl：日期和时间</span><br><span class="line"></span><br><span class="line">   98. UserAccountControlSettings用户账户控制设置</span><br><span class="line"></span><br><span class="line">   99. utilman：辅助工具管理器</span><br><span class="line"></span><br><span class="line">   100 .wf.msc：高级安全Windows防火墙</span><br><span class="line"></span><br><span class="line">   101. WFS：Windows传真和扫描</span><br><span class="line"></span><br><span class="line">   102. wiaacmgr：扫描仪和照相机向导</span><br><span class="line"></span><br><span class="line">   103. winver：关于Windows</span><br><span class="line"></span><br><span class="line">   104. wmimgmt.msc：打开windows管理体系结构(WMI)</span><br><span class="line"></span><br><span class="line">   105. write：写字板</span><br><span class="line"></span><br><span class="line">   106. wscui.cpl：操作中心</span><br><span class="line"></span><br><span class="line">   107. wuapp：Windows更新</span><br><span class="line"></span><br><span class="line">   108. wscript：windows脚本宿主设置</span><br></pre></td></tr></table></figure><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li><a href="http://www.windowszj.com/news/win10/28486.html" target="_blank" rel="noopener">windows系统之家</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;记录&lt;code&gt;window10&lt;/code&gt;CMD下面的一些命令&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="Others" scheme="http://roux.top/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>C++陷阱与用法</title>
    <link href="http://roux.top/2018/12/14/C++%E9%99%B7%E9%98%B1%E4%B8%8E%E7%94%A8%E6%B3%95/"/>
    <id>http://roux.top/2018/12/14/C++陷阱与用法/</id>
    <published>2018-12-13T16:00:00.000Z</published>
    <updated>2018-12-18T10:58:08.716Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>C++是一门很容易采坑的语言，所以对其一些常见的陷阱和误解进行收集与总结，同时对一些新的特性进行了解。</li><li>此文包含了自己遇到的问题以及在公司看到一位师兄写的文章的一些内容，外加一些网上看到的(代码已验证)</li></ul><a id="more"></a><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><ol><li><p><strong>编译器为什么不给局部变量和成员变量做默认初始化</strong></p><ul><li><strong>因为效率</strong>，C++被设计为系统级的编程语言，效率是优先考虑的方向，c++秉持的一个设计哲学是不为不必要的操作付出任何额外的代价</li><li>从安全的角度出发，定义变量的时候赋初值是一个好的习惯，<strong>很多错误皆因未正确初始化而起</strong>，C++11支持成员变量定义的时候直接初始化，成员变量尽量在成员初始化列表里初始化，且要按定义的顺序初始化</li></ul></li><li><p><strong>全局变量</strong></p><ul><li><strong>C++在不同模块（源文件）里定义的全局变量，不保证构造顺序</strong>；但保证在同一模块（源文件）里定义的全局变量，按定义的先后顺序构造，按定义的相反次序析构</li><li><strong>如果全局变量有依赖关系，那么就把它们放在同一个源文件定义，且按正确的顺序定义，确保依赖关系正确</strong>，而不是定义在不同源文件；对于系统中的单件，单件依赖也要注意这个问题</li></ul></li><li><p><strong>new与delete</strong></p><ul><li>delete之后加上语句<code>delete p; p = nullptr;</code>（避免重复释放）</li><li>保证<code>delete[]</code>匹配<code>new[]</code>和<code>delete</code>匹配<code>new</code></li><li>例外：<code>typedef T type[N];</code> <code>T * pT = new type; delete[] pT;</code></li></ul></li><li><p><strong>模板特化</strong></p><ul><li>C++ 本身要求，那几个自动生成的特殊的构造函数以及运算符必须是非模版</li><li>模版产生的函数一定与普通函数不等价。也就是意味着，模版无法生成那些函数与运算符，也不能重写虚函数</li><li>C++ 不允许在类域内显式特化类成员函数</li></ul></li><li><p><strong>enum hack</strong></p><ul><li><code>enum hack</code>的行为更像<code>#define</code>而不是<code>const</code>，如果你不希望别人得到你的常量成员的指针或引用，你可以用<code>enum hack</code>替代之。（为什么不直接用<code>#define</code>呢？首先，因为<code>#define</code>是字符串替换，所以不利于程序调试。其次，<code>#define</code>的可视范围难以控制，比如你怎么让<code>#define</code>定义的常量只在一个类内可见呢？除非你用<code>#undef</code></li><li>使用<code>enum hack</code>不会导致 “不必要的内存分配”</li><li><p>使用技巧：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// static const int GameTurn;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;GameTurn = <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> scores[GameTurn];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// const int Game::GameTurn = 10;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>#define宏</strong></p><ul><li>多用圆括号<code>#define ADD(a, b) ((a)+(b))</code></li><li><p>看情况使用花括号(用大括号将宏定义的多条表达式括起来)(<code>if语句`</code>do{}while(0)语句`等)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) \</span></span><br><span class="line">&#123; \</span><br><span class="line">    a ^=b; \</span><br><span class="line">    b ^=a; \</span><br><span class="line">    a ^=b; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>结构体的string赋值</strong></p><ul><li><p>代码1：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">      <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">World</span> &#123;</span></span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">World</span> *<span class="title">next</span>;</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          World *wr = (World*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(World));</span><br><span class="line">          wr-&gt;name = <span class="string">"hello"</span>;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; wr-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>最终的输出不是简单的一个<code>hello</code>，可以发现返回的code不是0并且会运行很长时间(Segmentation fault)。原因是这里用的是C中的<code>malloc</code>而不是<code>new</code></li><li><code>new</code>在分配内存时会调用默认的构造函数，而<code>malloc</code>不会调用(string没有调用构造函数导致错误)</li></ul></li><li><p>代码2：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">      <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"hello"</span>;  </span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str();  <span class="comment">// 指针常量  </span></span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">          s[<span class="number">1</span>] = <span class="string">'m'</span>;  </span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>两个输出分别为<code>hello</code>和<code>hmllo</code>。原因是<code>string的c_str()</code>返回的指针是由string管理的，因此它的生命期是string对象的生命期，而string类的实现实际上封装着一个<code>char*</code>的指针，而<code>c_str()</code>直接返回该指针的引用，因此string对象的改变会直接影响已经执行过的c_str()返回的指针引用</li></ul></li></ul></li><li><p><strong>eof与fail</strong></p><ul><li><strong>只要遇到结束符，流就会将状态置为EOF，而不管置位前的操作是否成功</strong>。因此，不能在调用函数后通过eof来判断函数调用是否读到文件末尾了，而应该直接判断调用本身是否成功</li><li><strong>在文件eof的时候也会同时置fail</strong>，所以，循环读取文件的时候，要将fail和eof结合起来使用：在循环判断中使用fail，fail失败后再使用eof</li></ul></li><li><p><strong>stream与buffer</strong></p><ul><li>前面<code>stream</code>后面<code>buffer</code></li><li>作用：<code>代表一个设备</code> <code>数据临时存储</code></li><li>访问方式：<code>FIFO</code> <code>随机访问</code></li><li><p>数据内容：<code>字符流</code> <code>二进制</code></p></li><li><p>当然，并不是说stream和buffer就毫无关系了，stream为了提高性能，实现的时候就用到了buffer</p></li></ul></li><li><p><strong>操作符短路</strong></p><ul><li><p>考虑以下函数：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  Play::get() &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApple() || getMelon()) &#123;</span><br><span class="line">        eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<code>getApple()</code>返回<code>true</code>,就不会就不会调用<code>getMelon()</code>了。这就是操作符短路</li></ul></li><li><p>修改如下：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  Play::get() &#123;</span><br><span class="line"><span class="keyword">bool</span> apple = getApple();</span><br><span class="line"><span class="keyword">bool</span> melon = getMelon();</span><br><span class="line">    <span class="keyword">if</span> (apple || melon) &#123;</span><br><span class="line">        eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>stl容器的遍历删除要小心迭代器失效，vector,list,map,set等各有不同的写法</strong> </p><ul><li>详情跳转<a href="http://roux.top/2018/12/14/C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88/">此文</a>    </li></ul></li><li><p><strong>理解const</strong></p><ul><li>积极的使用const，理解const不仅仅是一种语法层面的保护机制，也会影响程序的编译和运行（const常量会被编码到机器指令）</li></ul></li><li><p><strong>四种转型</strong></p><ul><li>尽量少用转型，强制类型转换是C Style，如果你的C++代码需要类型强转，你需要去考虑是否设计有问题</li></ul></li><li><p><strong>规范的代码</strong></p><ul><li>打开的句柄要关闭，加锁/解锁，new/delete，new[]/delete[]，malloc/free要配对，可以使用RAII技术防止资源泄露，编写符合规范的代码</li></ul></li><li><p><strong>抽象基类的析构函数要加virtual关键字</strong></p><ul><li>virtual dtor跟普通虚函数一样，基类指针指向子类对象的时候，delete ptr，根据虚函数特征，如果析构函数是普通函数，那么就调用ptr显式（基类）类型的析构函数；如果析构函数是virtual，则会调用子类的析构函数，然后再调用基类析构函数</li></ul></li><li><p><strong>避免在构造函数和析构函数里调用虚函数</strong></p><ul><li>构造函数里，对象并没有完全构建好，此时调用虚函数不一定能正确绑定，析构亦如此</li></ul></li><li><p><strong>协议尽量不要传float，如果传float要了解NaN的概念，要做好检查，避免恶意传播</strong></p></li><li><p><strong>字节对齐</strong></p><ul><li>字节对齐能让存储器访问速度更快。 </li><li>字节对齐跟cpu架构相关，有些cpu访问特定类型的数据必须在一定地址对齐的储存器位置，否则会触发异常。</li><li>字节对齐的另一个影响是调整结构体成员变量的定义顺序，有可能减少结构体大小，这在某些情况下，能节省内存</li></ul></li><li><p><strong>减少依赖，注意隔离</strong></p><ul><li>最大限度的减少文件间的依赖关系，用前向声明拆解相互依赖。了解pimpl技术。</li><li>头文件要自给自足，不要包含不必要的头文件，也不要把该包含的头文件推给user去包含，一句话，头文件包含要不多不少刚刚好</li></ul></li><li><p><strong>整型一般用int，long就好，用short，char需要很仔细，要防止溢出</strong></p><ul><li>大多数情况下，用int，long就很好，long一般等于机器字长，long能直接放到寄存器，硬件处理起来速度也更快</li><li>由于字节对齐，用short，char可能大小并不能真正减少，而且1,2个字节的整型位数太少，很容易溢出</li></ul></li><li><p><strong>std::map还是std::unorder_map</strong> </p><ul><li>想清楚他们的利弊，map是用红黑树做的，unorder_map底层是hash表做的，hash表相对于红黑树有更高的查找性能。hash表的效率取决于hash算法和冲突解决方法（一般是拉链法，hash桶），以及数据分布，如果负载因子高，就会降低命中率，为了提高命中率，就需要扩容，重新hash，而重新hash是很慢的，相当于卡一下。而红黑树有更好的平均复杂度，所以如果数据量不是特别大，map是胜任的</li></ul></li><li><p><strong>循环可终止</strong></p><ul><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">5</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>组合优先于继承，继承是一种最强的类间关系</strong></p></li><li><p><strong>了解延迟计算和分散计算</strong> </p><ul><li>分散计算是把任务分散，打碎，避免一次大计算量，卡住程序</li><li>延迟计算和分散计算都是常见的套路</li></ul></li><li><p><strong>从输入流获取数据，要做好数据不够的处理，要加try catch；没有被吞咽的exception，会被传播</strong></p></li><li><p><strong>内存拷贝小心内存越界；memcpy，memset有很强的限制，仅能用于<a href="http://roux.top/2018/12/13/C++%E4%B9%8BPOD%E7%B1%BB%E5%9E%8B/">POD结构</a>，不能作用于stl容器或者带有虚函数的类</strong></p><ul><li>带虚函数的类对象会有一个虚函数表的指针，memcpy将破坏该指针指向</li></ul></li><li><p><strong>用户stack空间很有限</strong></p><ul><li>一般而言，用户栈只有几兆（典型大小是4M，8M），所以栈上创建的对象不能太大；虽然递归函数能简化程序编写，但也常常带来运行速度变慢的问题，所以需要预估好递归深度，优先考虑非递归实现版本</li></ul></li><li><p><strong>函数调用的性能开销</strong></p><ul><li>函数调用的性能开销（栈帧建立和销毁，参数传递，控制转移），性能敏感函数考虑inline</li><li>X86_64体系结构因为通用寄存器数目增加到16个，所以64位系统下参数数目不多的函数调用，将会由寄存器传递代替压栈方式传递参数，但栈帧建立、撤销和控制转移依然会对性能有所影响</li></ul></li><li><p><strong>安全版本函数</strong></p><ul><li>用c标准库的安全版本（带n标识）替换非安全版本 ，比如用strncpy替代strcpy，用snprintf替代sprintf，用strncat代替strcat，用strncmp代替strcmp，memcpy(dst, src, n)要确保[dst，dst+n]和[src, src+n]都有有效的虚拟内存地址空间。；</li><li>多线程环境下，要用系统调用或者库函数的安全版本代替非安全版本（_r版本），谨记strtok，gmtime等标准c函数都不是线程安全的</li></ul></li><li><p><strong>理解std::vector的底层实现</strong></p><ul><li>vector是动态扩容的，2的次方往上翻，为了确保数据保存在连续空间，每次扩充，会将原member悉数拷贝到新的内存块； 不要保存vector内对象的指针，扩容会导致其失效 ；可以通过保存其下标index替代</li><li>运行过程中需要动态增删的vector，不宜存放大的对象本身 ，因为扩容会导致所有成员拷贝构造，消耗较大，可以通过保存对象指针替代</li><li>理解at()和operator[]的区别 ：at()会做下标越界检查，operator[]提供数组索引级的访问，在release版本下不会检查下标，VC会在Debug版本会检查；c++标准规定:operator[]不提供下标安全性检查</li><li>resize()是重置大小；reserve()是预留空间，并未改变size()，可避免多次扩容； clear()并不会导致空间收缩 ，如果需要释放空间，可以跟空的vector交换，std::vector <t>.swap(v)，c++11里shrink_to_fit()也能收缩内存</t></li></ul></li><li><p><strong>std::sort()的比较函数有很强的约束</strong></p><ul><li>如果要用，要自己提供比较函数或者函数对象，一定搞清楚什么叫<a href="http://roux.top/2018/12/13/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F/">严格弱排序</a></li><li>尽量对索引或者指针sort，而不是针对对象本身，因为如果对象比较大，交换（复制）对象比交换指针或索引更耗费</li></ul></li><li><p><strong>用sprintf格式化字符串的时候，类型和格式化符号要严格匹配，因为sprintf的函数实现里是按格式化串从栈上取参数，任何不一致，都有可能引起不可预知的错误； /usr/include/inttypes.h里定义了跨平台的格式化符号，比如PRId64用于格式化int64_t</strong></p></li><li><p><strong>了解智能指针，理解基于引用计数法的智能指针实现方式，了解所有权转移的概念，理解shared_ptr和unique_ptr的区别和适用场景</strong></p></li></ol><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><ul><li>首先很感谢我认识的师兄，在他们那里学到了很多的知识</li><li>本文后面会不时的更新，有错误的地方点击右下角联系我，谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C++是一门很容易采坑的语言，所以对其一些常见的陷阱和误解进行收集与总结，同时对一些新的特性进行了解。&lt;/li&gt;
&lt;li&gt;此文包含了自己遇到的问题以及在公司看到一位师兄写的文章的一些内容，外加一些网上看到的(代码已验证)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="语言" scheme="http://roux.top/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://roux.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++迭代器失效</title>
    <link href="http://roux.top/2018/12/14/C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88/"/>
    <id>http://roux.top/2018/12/14/C++迭代器失效/</id>
    <published>2018-12-13T16:00:00.000Z</published>
    <updated>2018-12-18T10:58:01.935Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>C++迭代器很好用，但是使用的时候一不留神就会出错，迭代器失效就是其中之一。</li></ul><a id="more"></a><h4 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h4><ol><li><p>list, set, map容器</p><ul><li>在使用 list、set 或 map遍历删除某些元素时可以这样使用：</li><li><p>正确写法1：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itList;</span><br><span class="line"><span class="keyword">for</span> (itList = List.begin(); itList != List.end(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (WillDelete(*itList)) &#123;</span><br><span class="line">         itList = List.erase(itList);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         itList++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正确写法2：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itList;</span><br><span class="line">   <span class="keyword">for</span> (itList = List.begin(); itList != List.end(); ) &#123;</span><br><span class="line">       <span class="keyword">if</span> (WillDelete( *itList)) &#123;</span><br><span class="line">           List.erase(itList++);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           itList++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>错误写法1：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itList;</span><br><span class="line">      <span class="keyword">for</span> (itList = List.begin(); itList != List.end(); itList++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (WillDelete(*itList)) &#123;</span><br><span class="line">              List.erase(itList);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>错误写法2：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itList;</span><br><span class="line">      <span class="keyword">for</span> (itList = List.begin(); itList != List.end(); ) &#123;</span><br><span class="line">          <span class="keyword">if</span> (WillDelete(*itList)) &#123;</span><br><span class="line">              itList = List.erase(++itList);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               itList++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>分析：</p><ol><li>正确使用方法1：通过erase方法的返回值来获取下一个元素的位置</li><li>正确使用方法2：在调用erase方法之前先使用 “++” 来获取下一个元素的位置</li><li>错误使用方法1：在调用erase方法之后使用 “++” 来获取下一个元素的位置，由于在调用erase方法以后，该元素的位置已经被删除，如果在根据这个旧的位置来获取下一个位置，则会出现异常。</li><li>错误使用方法2：同错误使用方法1</li></ol></li></ul></li><li><p>vector, deque容器</p><ul><li>在使用 vector、deque遍历删除元素时，也可以通过erase的返回值来获取下一个元素的位置</li><li><p>正确写法：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Vec;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itVec;</span><br><span class="line">      <span class="keyword">for</span>(itVec = Vec.begin(); itVec != Vec.end(); ) &#123;</span><br><span class="line">          <span class="keyword">if</span>(WillDelete( *itVec) ) &#123;</span><br><span class="line">              itVec = Vec.erase(itVec);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              itList++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意：</strong></p><ol><li><p>vector、deque 不能像上面的<code>正确使用方法2</code>的办法来遍历删除</p><ol><li>对于关联容器(如map, set, multimap,multiset)，删除当前的iterator，<strong>仅仅会使当前的iterator失效</strong>，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响</li><li>对于序列式容器(如vector,deque)，<strong>删除当前的iterator会使后面所有元素的iterator都失效</strong>。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。但是erase方法可以返回下一个有效的iterator</li><li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种方法都可以使用</li></ol></li></ol></li></ul></li></ol><h4 id="相关容器介绍"><a href="#相关容器介绍" class="headerlink" title="相关容器介绍"></a>相关容器介绍</h4><ol><li><p>vector</p><ul><li>内部数据结构：数组</li><li>访问：随机访问每个元素，所需要的时间为常量</li><li>增删元素：在末尾增加或删除元素所需时间与元素数目无关，在中间或开头增加或删除元素所需时间随元素数目呈线性变化</li><li>迭代器：vector的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。当把超过capacity()-size()个元素插入vector中时，内存会重新分配，所有的迭代器都将失效；否则，指向当前元素以后的任何元素的迭代器都将失效。当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效</li></ul></li><li><p>deque</p><ul><li>内部数据结构：数组</li><li>访问：随机访问每个元素，所需要的时间为常量</li><li>增删元素：在开头和末尾增加元素所需时间与元素数目无关，在中间增加或删除元素所需时间随元素数目呈线性变化</li><li>迭代器： 增加任何元素都将使deque的迭代器失效。在deque的中间删除元素将使迭代器失效。在deque的头或尾删除元素时，只有指向该元素的迭代器失效</li></ul></li><li><p>lsit</p><ul><li>内部数据结构：双向环状链表</li><li>访问：不能随机访问一个元素</li><li>增删元素：在开头、末尾和中间任何地方增加或删除元素所需时间都为常量</li><li>迭代器：增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效</li></ul></li><li><p>slist</p><ul><li>内部数据结构：单向链表</li><li>访问：不可双向遍历，只能从前到后地遍历</li><li>增删元素：在开头、末尾和中间任何地方增加或删除元素所需时间都为常量</li><li>迭代器：增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效</li></ul></li><li><p>stack</p><ul><li>内部数据结构：适配器，它可以将任意类型的序列容器转换为一个堆栈，一般使用deque作为支持的序列容器</li><li>访问：不能遍历整个stack</li><li>增删元素：元素只能后进先出</li></ul></li><li><p>queue</p><ul><li>内部数据结构：适配器，它可以将任意类型的序列容器转换为一个队列，一般使用deque作为支持的序列容器</li><li>访问：不能遍历整个queue</li><li>增删元素：元素只能先进先出</li></ul></li><li><p>priority_queue</p><ul><li>内部数据结构：适配器，它可以将任意类型的序列容器转换为一个优先级队列，一般使用vector作为底层存储方式</li><li>访问：只能访问第一个元素，不能遍历整个priority_queue</li><li>增删元素：第一个元素始终是优先级最高的一个元素</li></ul></li><li><p>set(hash_set不解释了)</p><ul><li>内部数据结构：红黑树</li><li>访问：随机访问</li><li>增删元素：键和值相等且键唯一</li><li>迭代器：如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效</li></ul></li><li><p>map(hash_map不解释了)</p><ul><li>内部数据结构：红黑树</li><li>访问：随机访问</li><li>增删元素：键唯一</li><li>迭代器：如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C++迭代器很好用，但是使用的时候一不留神就会出错，迭代器失效就是其中之一。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="语言" scheme="http://roux.top/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://roux.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++之POD类型</title>
    <link href="http://roux.top/2018/12/13/C++%E4%B9%8BPOD%E7%B1%BB%E5%9E%8B/"/>
    <id>http://roux.top/2018/12/13/C++之POD类型/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-18T10:57:56.051Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><p><code>POD(Plain Old Data)</code>是C++中非常重要的一个概念，用来描述一个类型的属性。其中<code>Plain</code>表示这个类型是个平凡的类型，<code>Old</code>表示其与C的兼容性(就意味着可以使用 memcpy() 函数进行操作)。</p></li><li><p>C++11中将POD划分为两个基本概念：<code>平凡的（trival）</code>和<code>标准布局（standardlayout）</code></p></li></ul><a id="more"></a><h4 id="平凡-trival"><a href="#平凡-trival" class="headerlink" title="平凡(trival)"></a>平凡(trival)</h4><ul><li>满足条件<ol><li><strong>不能写 <code>构造/析构函数</code>、<code>拷贝/移动构造函数</code>、<code>拷贝/移动赋值运算符</code></strong>，而是用编译器自动为我们生成，那这个数据就是“平凡的”。非要写的话，用 C++ 11 的 <code>default</code> 关键字。<ul><li>C++为我们提供了一个类模板来识别一个类是否平凡：<code>template &lt;typename T&gt; struct std::is_trival</code></li></ul></li><li><strong>不能有 <code>虚函数</code> 和 <code>虚基类</code></strong>。</li></ol></li></ul><h4 id="标准布局"><a href="#标准布局" class="headerlink" title="标准布局"></a>标准布局</h4><ul><li><p>满足条件</p><ol><li><strong>普通成员有相同的访问级别</strong></li><li><strong>第一个成员必须是自己的</strong>(也即类中第一个非静态成员的类型与其基类不同)</li><li><strong>只要有父类，普通成员只能在其中一个类中，不可分散</strong>(也即<code>派生类中有非静态成员，且只有一个仅包含静态成员的基类</code>或者<code>基类有非静态成员，而派生类没有非静态成员</code>)</li><li><strong>没有虚函数和虚基类</strong></li></ol><ul><li><p>C++提供了一个模板来判断一个类或者结构体是否是标准布局:<code>template &lt;typename T&gt; struct std::is_standard_layout; //头文件为&lt;type_traits&gt;</code></p></li><li><p>C++提供了一个模板来判断一个类或者结构体是否是POD:<code>template &lt;typename T&gt; struct std::is_pod //头文件为&lt;type_traits&gt;</code></p></li></ul></li></ul><h4 id="POD的好处"><a href="#POD的好处" class="headerlink" title="POD的好处"></a>POD的好处</h4><ol><li><p>字节赋值，我们可以放心的使用<code>memset</code>和<code>memcpy</code>对POD类型进行初始化和拷贝。</p></li><li><p>提供对C内存的兼容。POD类型的数据在C与C++间的操作总是安全的。</p></li><li><p>保证了静态初始化的安全有效。POD类型的对象初始化往往更简单</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;POD(Plain Old Data)&lt;/code&gt;是C++中非常重要的一个概念，用来描述一个类型的属性。其中&lt;code&gt;Plain&lt;/code&gt;表示这个类型是个平凡的类型，&lt;code&gt;Old&lt;/code&gt;表示其与C的兼容性(就意味着可以使用 memcpy() 函数进行操作)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C++11中将POD划分为两个基本概念：&lt;code&gt;平凡的（trival）&lt;/code&gt;和&lt;code&gt;标准布局（standardlayout）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="语言" scheme="http://roux.top/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://roux.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 严格弱序</title>
    <link href="http://roux.top/2018/12/13/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F/"/>
    <id>http://roux.top/2018/12/13/严格弱序/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-18T10:54:22.378Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>学习C++11遇到的重要的点。</li></ul><a id="more"></a><h4 id="什么是严格弱序"><a href="#什么是严格弱序" class="headerlink" title="什么是严格弱序"></a>什么是严格弱序</h4><ul><li><code>C++关联容器</code>的有序容器对元素关键字的类型有要求，元素关键字的类型必须定义了<code>严格序（stick weak ordering）</code> ，以内置类型来说，C++都定义了<code>“&lt;”</code>操作符，这就是一个严格弱序，而<code>“&lt;=”</code>就不是一个严格弱序</li></ul><h4 id="表示与作用"><a href="#表示与作用" class="headerlink" title="表示与作用"></a>表示与作用</h4><ul><li><p>a小于b：<code>a &lt; b</code></p></li><li><p>a大于b：<code>a &gt; b</code></p></li><li><p>a等于b：<code>!(a &lt; b) &amp;&amp; !(a &gt; b)</code></p></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>非自反性： 如果存在两个关键字，任何一个都不<code>严格弱序</code>于另一个，则这两个关键字是相等的，<code>即comp(a, a)必须是false</code></li><li>非对称性： 两个关键字不能同时<code>严格弱序</code>于对方，<code>即如果comp(a, b)和comp(b, a)的结果必然相反</code></li><li>传递性：如果a<code>严格弱序</code>于b，且b<code>严格弱序</code>于c，则a必须<code>严格弱序</code>于c，<code>即如果comp(a, b)为true，comp(b, c)为true，那么comp(a, c)必然为true</code></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>有序关联容器不允许存在相同的关键字，在用<code>compare函数</code>判断时，会认为相同的关键字是不相等的，因此会将两个相同的关键字插入容器中，这个行为是未定义的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;学习C++11遇到的重要的点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Others" scheme="http://roux.top/categories/Others/"/>
    
    
      <category term="C++" scheme="http://roux.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>不将就</title>
    <link href="http://roux.top/2018/10/24/%E4%B8%8D%E5%B0%86%E5%B0%B1/"/>
    <id>http://roux.top/2018/10/24/不将就/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2019-01-06T12:20:50.690Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;对最近的一段时间进行梳理。</p><a id="more"></a><p>&emsp;&emsp;自从实习结束并回到学校后，持续过了一个月的“闲人”生活，期间，中秋结束后和好基友<code>张越</code>完成了为期11天的旅游，欣赏了这个世界的美丽(当然包括小姐姐们，享受脸.jpg)，也享受了各种美食，很开心(很感谢我儿子一路上的规划，简直完美）。<br>&emsp;&emsp;国庆节后，开始阅读技术书籍，同时参与一些分享活动。期间，身边人找工作也都陆续结束，各种玩耍，各种皮。关于女朋友这事也被提及的越来越多，自己也想了想，的确是在很多难过或者困难的时候，有个人在一起陪伴或者安慰都是极棒的，这也导致我曾经一度想找个先这样。不过对自己生活的不满意，对自己要求的提升，让我觉得这算是对生活的一种妥协，我还年轻，还有机会去尝试，所以不能轻易妥协。<br>&emsp;&emsp;现在，努力提升自己，让自己过得精致一点，多多投资自己，保持一种态度：对生活，不将就！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;对最近的一段时间进行梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://roux.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://roux.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>实习总结</title>
    <link href="http://roux.top/2018/08/31/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://roux.top/2018/08/31/实习总结/</id>
    <published>2018-08-30T16:00:00.000Z</published>
    <updated>2018-10-25T08:59:32.717Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;work hard， work smart！<br><a id="more"></a></p><p>&emsp;&emsp;不知不觉三个月的实习就结束了，也许只有到最后要走的时候才会真正的感受到一些别样的情绪充斥在心间。感谢这段时间师兄师姐们的指导与帮助，也很开心能够遇见这么多的小伙伴！<br>&emsp;&emsp;最终得知转正的结果还是很开心的，后面呢，也准备留在阿里了。以这段时间的感受来说：阿里是一家很有责任感的公司、公司内部的腐败程度个人感觉还是较其他公司好的、阿里的价值观我表示认同、最主要的是身边的小伙伴们都很nice。感觉这里面的环境很适合我，个人也比较懒，也就不想再换公司了（换公司的话，这种环境很难说）<br>&emsp;&emsp;实习期间学到的东西还是很多的，主要是开了眼界，思想上有了相应的提升，对大公司的流程什么的都有了了解，而且对自己后面的方向也能够做出一些选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;work hard， work smart！&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://roux.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://roux.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Vmware的一些问题</title>
    <link href="http://roux.top/2018/05/10/Vmware%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://roux.top/2018/05/10/Vmware的一些问题/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-18T08:40:15.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>前几天换了个电脑，于是所有的东西都需要拷贝和重装，在装vmware的时候遇到了一些问题，所以记录在这里。</li></ul><a id="more"></a><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><p>windows7</p><ul><li>可以安装任何的版本，而且安装所有的系统都是没问题的。要注意的就是对vmware的服务要保持开启，给centos7安装vmtools的时候有点麻烦。这里注意的没有什么太多。</li></ul></li><li><p>windows10</p><ul><li><p>这里的话在安装vmware的时候需要安装vmware12及以上的版本，官方给的说明是11的时候就开始支持windows10了，但是我在装ubuntu16.04的时候直接报错导致安装失败，之后我使用12版本的直接成功。在这里需要注意的是在装系统的时候需要把硬件定制里面的显示的3D图形加速关闭，否则会出现黑屏的现象。如果ubuntu出现屏幕分辨率的问题导致无法点击安装过程中的确认或者下一步按钮的情况，可以先试用，然后选择设置修改分辨率，让其适合当前的分辨率，然后再次进入就可以看到和选择了。</p></li><li><p>由于中间有一次直接用杀毒软件结束掉了VMware，导致我在下一次打开ubuntu的时候显示正在使用中，用了其他的一些方法也都没解决，最终找到一个方法简单粗暴：找到安装操作系统的目录，进去后会看到两个后缀为<code>.lck</code>的文件夹，把这两个文件夹剪切出来（删除掉也可以，你打开以后会重建），然后再打开虚拟机就没问题了。具体的原因还没去了解。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;前几天换了个电脑，于是所有的东西都需要拷贝和重装，在装vmware的时候遇到了一些问题，所以记录在这里。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="VMware" scheme="http://roux.top/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>HTTP2.0</title>
    <link href="http://roux.top/2018/04/22/HTTP2.0/"/>
    <id>http://roux.top/2018/04/22/HTTP2.0/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-10-21T13:47:33.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p>这篇文章主要是对HTTP2.0进行一个总结，把零散的知识点进行连接。</p></li><li><p>HTTP2.0 的目的是通过支持请求与响应的多路复用来较少延迟，通过压缩 HTTPS 首部字段将协议开销降低，同时增加请求优先级和服务器端推送的支持.</p></li></ul><a id="more"></a><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><ul><li><p>二进制分帧层，是HTTP 2.0性能增强的核心。 </p><ul><li>HTTP 1.x在应用层以纯文本的形式进行通信，而HTTP 2.0将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。这样，客户端和服务端都需要引入新的二进制编码和解码的机制。</li></ul></li><li><p><strong>帧</strong></p><ol><li><p><strong>帧的分类</strong></p><ol><li>DATA：用于传输 HTTP 消息体；</li><li>HEADERS：用于传输首部字段；</li><li>SETTINGS：用于约定客户端和服务端的配置数据。比如设置初识的双向流量控制窗口大小；</li><li>WINDOW_UPDATE：用于调整个别流或个别连接的流量</li><li>PRIORITY： 用于指定或重新指定引用资源的优先级。</li><li>RST_STREAM： 用于通知流的非正常终止。</li><li>PUSH_ PROMISE： 服务端推送许可。</li><li>PING： 用于计算往返时间，执行 “活性” 检活。</li><li>GOAWAY： 用于通知对端停止在当前连接中创建流<br><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/HTTP2.0.png" alt=""></li></ol><ul><li>标志位用于不同的帧类型定义特定的消息标志。比如 DATA 帧就可以使用End Stream: true表示该条消息通信完毕。流标识位表示帧所属的流 ID。优先值用于 HEADERS 帧，表示请求优先级。R 表示保留位。</li></ul></li><li><p><strong>消息</strong></p><ul><li>消息是指逻辑上的HTTP消息（请求/响应）。一系列数据帧组成了一个完整的消息。比如一系列DATA帧和一个HEADERS帧组成了请求消息。</li></ul></li><li><p><strong>流</strong></p><ol><li>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流 ID 冲突，客户端发起的流具有奇数 ID，服务器端发起的流具有偶数 ID。 </li><li>所有 HTTP2.0通信都在一个 TCP 连接上完成，慢启动时间减少,拥塞和丢包恢复速度更快，这个连接可以承载任意数量的双向数据流 Stream。相应地，每个数据流以 消息的形式发送，而消息由一 或多个帧组成，这些帧可以乱序发送，然后根据每个帧首部的流标识符重新组装。</li></ol></li></ol></li><li><p><strong><a href="https://www.nihaoshijie.com.cn/index.php/archives/698/" target="_blank" rel="noopener">多路复用</a></strong></p><ol><li><p>HTTP1.X如果不用<a href="https://blog.csdn.net/qq_28885149/article/details/52922107" target="_blank" rel="noopener">pipeling</a>的话会实现串行传输（一个得到应答才继续下一个），如果使用<a href="https://blog.csdn.net/qq_28885149/article/details/52922107" target="_blank" rel="noopener">pipeling</a>的话会<a href="https://blog.csdn.net/jiyiqinlovexx/article/details/50500246" target="_blank" rel="noopener">建立多条TCP连接</a>，这会导致开销增大</p></li><li><p>HTTP2.0建立一条TCP连接后，会并行传输数据。HTTP 2.0成功解决了HTTP 1.x的队首阻塞问题（TCP层的阻塞仍无法解决），同时，也不需要通过pipeline机制多条TCP连接来实现并行请求与响应。减少了TCP连接数对服务器性能也有很大的提升。</p></li><li><p>HTTP1.X虽然可以采用keep alive来解决复用TCP的问题，但是还是无法解决请求阻塞问题。</p><ul><li>所谓请求阻塞意思就是一条TCP的connection在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。</li><li>之所以有这个问题就是因为HTTP1.x需要每条请求都是可是识别，按顺序发送，否则server就无法判断该相应哪个具体的请求。</li><li>HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输，每个stream有唯一标识，connection一旦建立，后续的请求都可以复用这个connection并且可以同时发送，server端可以根据stream的唯一标识来相应对应的请求。</li></ul></li></ol></li><li><p><strong>请求优先级</strong></p><ul><li><p>流可以带有一个31bit的优先级：</p><ul><li>0：表示最高优先级</li><li>2^31-1：表示最低优先级</li></ul></li><li><p>客户端明确指定优先级，服务端可以根据这个优先级作为依据交互数据，比如客户端优先级设置为.css&gt;.js&gt;.jpg（具体可参见《高性能网站建设指南》）， 服务端按优先级返回结果有利于高效利用底层连接，提高用户体验。 </p></li><li><p>然而，也不能过分迷信请求优先级，仍然要注意以下问题：</p><ul><li>服务端是否支持请求优先级</li><li>会否引起队首阻塞问题，比如高优先级的慢响应请求会阻塞其他资源的交互。</li></ul></li></ul></li><li><p><strong>服务端推送</strong></p><ul><li>HTTP 2.0增加了服务端推送功能，服务端可以根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。<ul><li>比如：客户端请求stream 1，/page.html。服务端在返回stream 1消息的同时推送了stream 2（/script.js）和stream 4（/style.css）。</li></ul></li></ul></li><li><p><strong>首部压缩</strong></p><ol><li>HTTP1.x在每一次通信都会携带首部信息描述资源属性</li><li>HTTP2.0会在双方之间使用“首部表”来跟踪之前发送和存储的键值对，首部表在链接过程中始终存在，新增的键值对会更新到表尾，因此不需要每次通信都携带首部</li><li>HTTP2.0用到了首部压缩技术，压缩算法为HPACK<ul><li>HTTP 2.0关注的是首部压缩，而我们常用的gzip等是报文内容（body）的压缩。二者不仅不冲突，且能够一起达到更好的压缩效果。</li></ul></li></ol></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://blog.csdn.net/zhuyiquan/article/details/69257126" target="_blank" rel="noopener">https://blog.csdn.net/zhuyiquan/article/details/69257126</a></li><li><a href="https://segmentfault.com/a/1190000013028798" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013028798</a></li><li><a href="https://www.nihaoshijie.com.cn/index.php/archives/698/" target="_blank" rel="noopener">https://www.nihaoshijie.com.cn/index.php/archives/698/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这篇文章主要是对HTTP2.0进行一个总结，把零散的知识点进行连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTP2.0 的目的是通过支持请求与响应的多路复用来较少延迟，通过压缩 HTTPS 首部字段将协议开销降低，同时增加请求优先级和服务器端推送的支持.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="HTTP" scheme="http://roux.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与HTTPS</title>
    <link href="http://roux.top/2018/04/22/HTTP%E4%B8%8EHTTPS/"/>
    <id>http://roux.top/2018/04/22/HTTP与HTTPS/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-04-22T06:28:42.803Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>HTTPS是对HTTP在安全方面上做的一个改进，HTTPS = HTTP + <a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">SSL/TLS</a></li></ul><a id="more"></a><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><p>https需要申请CA证书，需要一定的费用</p></li><li><p>http是明文传输，https是有安全性的ssl加密传输</p></li><li><p>http的端口是80，https是443</p></li><li><p>http是简单的，<a href="http://www.cnblogs.com/bellkosmos/p/5237146.html" target="_blank" rel="noopener">无状态</a>的，https是由http+sslL组成的进行加密传输、身份认证的协议，更加安全</p></li></ol><h3 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h3><ol><li><p>客户端发起请求，将自己支持的加密算法，打个包告诉服务器端</p></li><li><p>服务器端从客户端发来的加密算法中，选出一组加密算法和HASH算法（注，HASH也属于加密），并将自己的身份信息以证书的形式发回给客户端。而证书中包含了网站的地址，加密用的公钥，以及证书的颁发机构等；这里，服务器就将自己用来加密用的公钥一同发还给客户端，而私钥则服务器保存着，用户解密客户端加密过后的内容。</p></li><li><p>客户端收到内容</p><ol><li>验证一下证书是否合法。一般来说，证书是用来标示一个站点是否合法的标志。如果说该证书由权威的第三方颁发和签名的，则说明证书合法。</li><li>如果证书合法，或者客户端接受和信任了不合法的证书，则客户端就会随机产生一串序列号，使用服务器发来的公钥进行加密。这时候，一条返回的消息就基本就绪。</li><li>最后使用服务器挑选的HASH算法，将刚才的消息使用刚才的随机数进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。</li></ol></li><li><p>服务器接受到客户端发来的消息后</p><ol><li>使用私钥解密上面客户端公钥加密的消息，得到客户端产生的随机序列号</li><li>使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任</li><li>最后，使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息，发还给客户端。同时HASH值也带上</li></ol></li><li><p>客户端收到服务器端的消息后</p><ol><li>计算HASH值是否与发回的消息一致</li><li>检查消息是否为握手消息</li></ol></li><li><p>握手结束后，客户端和服务器端使用握手阶段产生的随机数以及挑选出来的算法进行对称加解密的传输</p></li></ol><h3 id="为什么不直接全程使用非对称加密算法进行数据传输"><a href="#为什么不直接全程使用非对称加密算法进行数据传输" class="headerlink" title="为什么不直接全程使用非对称加密算法进行数据传输"></a>为什么不直接全程使用非对称加密算法进行数据传输</h3><ol><li><p>因为非对称算法的效率对比起对称算法来说，要低得多得多；因此往往只用在HTTPS的握手阶段。</p></li><li><p>http建立连接114ms，https为436ms（ssl为322ms），针对computer science house（计算机科学院CSH）的测试</p></li></ol><h3 id="经常使用的加密算法"><a href="#经常使用的加密算法" class="headerlink" title="经常使用的加密算法"></a>经常使用的加密算法</h3><ol><li>非对称加密算法：RSA, DSA/DSS</li><li>对称加密算法： AES, 3DES</li><li>HASH算法：MD5, SHA1, SHA256</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HTTPS是对HTTP在安全方面上做的一个改进，HTTPS = HTTP + &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SSL/TLS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="HTTP" scheme="http://roux.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习（六）——HTTP2性能优化实践</title>
    <link href="http://roux.top/2018/04/22/HTTP%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://roux.top/2018/04/22/HTTP学习（六）/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-04-22T06:06:02.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>为了让我们的网站访问速度快变，我们不断增加带宽，做针对HTTP协议的特点对应用做各种优化。希望能通常高带宽，低延迟来提高网站到访问速度。带宽与延迟两者间，延迟才是性能的真正瓶颈。</li></ul><a id="more"></a><h3 id="客观原因"><a href="#客观原因" class="headerlink" title="客观原因"></a>客观原因</h3><ul><li><p>当我们针对HTTP协议进行性能优化时，我们不得不注意到这样的一些客观原因。通常当我们改变不了底层协议特性时，我们只能在更高层处做文章。</p><ol><li><p>带宽受物理层介质的影响，最快快不过光速，但是即便在今天越来越高的带宽，我们依然没有感觉到网站访问速度有多快。 </p></li><li><p>延迟包括传输延迟，传播延迟，处理延迟和排队延迟。</p></li><li><p>每次连接都需要经过3次握手才能建立，增加整整一个RTT。</p></li><li><p>TCP拥塞控制策略：慢启动，拥塞避免[注1]。其中慢启动会被应用到每一个连接中。TCP流量和拥塞控制会影响整个网络到吞吐量。</p></li><li><p>解析DNS必然会产生一些延迟。</p></li><li><p>最快获得资源的方式，莫过于还没传，就已拿到。充分利用缓存。</p></li><li><p>最少的延迟就是什么都不传。而没有延迟。</p></li></ol></li></ul><h3 id="针对HTTP1-X做过的优化"><a href="#针对HTTP1-X做过的优化" class="headerlink" title="针对HTTP1.X做过的优化"></a>针对HTTP1.X做过的优化</h3><ul><li><p>由于TCP层的特性，在提高web性能时，我们不得不做一些优化， <a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">Best Practices for Speeding Up Your Web Site</a>，这些优化中针对HTTP协议特点的，我们做了哪些呢，从总体来说有以下几大点。</p><ol><li><p>连接和拼接</p><ul><li>连接或拼接JS和CSS文件，雪碧图，以减少HTTP请求，同时浏览器可缓存这些静态资源，为下次访问节约时间。但是这样带来的副作用是，维护成本高，其中某一个小改动都会使得整个拼接后的文件发生改变，重新缓存。</li></ul></li><li><p>域名分区</p><ul><li>由于浏览器的限制，同一个域下最多只能建立6个连接。我们通常使用子域名来减少所有资源在只有一个连接时的产生的排队延迟。这个显然不适用在HTTP2中，因为不同的域需要建立不同的连接。</li></ul></li><li><p>资源内嵌</p><ul><li>对于不常用的，较小大资源内嵌在文档中，比如base64的图片，以减少HTTP请求，但是这样的资源不能在浏览器中缓存，也不可能被其他页面共享，同时还有可能编码之后的资源变等更大了。在HTTP2中，这样的资源就可以使用SERVER PUSH来推送。</li></ul></li><li><p>HTTP管道（额外的）</p><ul><li><p>在HTTP1.x中已经实现了持久连接，但是却依然需要排队来发送和接收请求，这样不能充分利用网络资源。因此提出了HTTP管道的概念。客户端可以将所有请求都一起发给服务器端，服务器端或者按顺序处理，或者并行处理这些请求。但是返回响应的顺序是按照其自己内部的优先级来的。</p></li><li><p>但是，其缺点也很多，以至于现在的浏览器对它还是默认关闭的：</p></li></ul></li><li><p>队首阻塞</p><ul><li>并行处理时，需要占用缓存资源，服务器容易受到攻击</li><li>响应失败后，会断开tcp连接，并要求重发之后的所有请求，造成资源浪费</li><li>中间代理对其兼容性不是很好，有可能还会串行所有请求</li></ul></li></ol></li></ul><h3 id="针对HTTP2需要做的优化"><a href="#针对HTTP2需要做的优化" class="headerlink" title="针对HTTP2需要做的优化"></a>针对HTTP2需要做的优化</h3><ul><li><p>坚决去掉在HTTP1.X中的域名分区，连接和拼接和资源内嵌的优化方式。</p></li><li><p>尽量让所有资源在同一域名下</p></li><li><p>利用服务器推送</p></li><li><p>继续保留CDN</p></li></ul><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><ul><li>TCP慢开始与拥塞避免示意图<br>  <img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/six/slow-start.png" alt=""></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://imjiaolong.cn/post/http2vshttp1.1.html" target="_blank" rel="noopener">https://imjiaolong.cn/post/http2vshttp1.1.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为了让我们的网站访问速度快变，我们不断增加带宽，做针对HTTP协议的特点对应用做各种优化。希望能通常高带宽，低延迟来提高网站到访问速度。带宽与延迟两者间，延迟才是性能的真正瓶颈。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="HTTP" scheme="http://roux.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析的过程</title>
    <link href="http://roux.top/2018/04/22/DNS%E8%A7%A3%E6%9E%90/"/>
    <id>http://roux.top/2018/04/22/DNS解析/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-04-22T06:26:43.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>对于网络这一块，有太多的学问，而且这个也是后面重点需要优化的方向，所以最近会写一些这方面的文章。</li></ul><a id="more"></a><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>在浏览器中输入<a href="http://www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。" target="_blank" rel="noopener">www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</a> </li><li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </li><li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </li><li>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 </li><li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com主机。" target="_blank" rel="noopener">www.qq.com主机。</a> </li><li>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 </li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>人们在 DNS 中发现了一些漏洞，攻击者可以利用这些漏洞劫持这一使用名称在 互联网 上搜寻某个人或某个站点的过程。这种攻击的目的是取得对会话的控制以实施某种操作，例如使用户进入劫持者自己设立的欺骗性网站，以便收集用户的帐户和密码。</p></li><li><p>安全的DNS—<a href="https://www.icann.org/resources/pages/dnssec-qaa-2014-01-29-zh" target="_blank" rel="noopener">DNSSEC</a></p></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.nowcoder.com/profile/2286733/myFollowings/detail/4794271" target="_blank" rel="noopener">https://www.nowcoder.com/profile/2286733/myFollowings/detail/4794271</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对于网络这一块，有太多的学问，而且这个也是后面重点需要优化的方向，所以最近会写一些这方面的文章。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="DNS" scheme="http://roux.top/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.0与HTTP1.1</title>
    <link href="http://roux.top/2018/04/22/HTTP1.0%E4%B8%8EHTTP1.1/"/>
    <id>http://roux.top/2018/04/22/HTTP1.0与HTTP1.1/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-04-22T12:26:10.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>前面的系列文章最终感觉有点零散，所以在这里将HTTP1.0和HTTP1.1的一些区别进行说明。</li></ul><a id="more"></a><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p><strong>可扩展性</strong></p><ol><li>为了与未来的协议规范兼容，HTTP1.1在请求消息中包含了Upgrade头域，客户端可以让服务器知道它能够支持的其他备用通信协议，服务器以此进行协议的切换</li><li>HTTP1.1增加了options方法，允许客户端获取服务器支持的方法列表</li><li>在消息中增加版本号，用来进行兼容判断。此版本号只可以判断逐段的兼容性，不能判断端到端的兼容性<ul><li>eg：一台HTTP/1.1的源服务器从使用HTTP/1.1的Proxy那儿接收到一条转发的消息，实际上源服务器并不知道终端客户使用的是HTTP/1.0还是HTTP/1.1。因此，HTTP/1.1定义Via头域，用来记录消息转发的路径，它记录了整个路径上所有发送方使用的版本号</li></ul></li></ol></li><li><p><strong>缓存</strong></p><ol><li>HTTP1.1在1.0的特性上加了一些cache的特性：当缓存的对象的age超过expire（最大时限）时变为stale（旧的）对象，cache不需要直接抛弃此对象，而是与服务器进行重新激活</li><li>HTTP1.1增加了Cache-Control头域（请求消息和响应消息都可用），它支持一个可扩展的指令子集：例如max-age指令支持相对时间戳；private和no-store指令禁止对象被缓存；no-transform阻止Proxy进行任何改变响应的行为</li></ol></li><li><p><strong>带宽优化</strong></p><ol><li>请求对象的部分<ul><li>HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。例如，客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。</li><li>HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象</li></ul></li><li>请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽<ul><li>HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。注意，HTTP/1.0的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue</li></ul></li><li>节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如jpeg图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式</li></ol></li><li><p><strong>长连接</strong></p><ol><li>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。<ul><li>在HTTP/1.0中，要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域，如果服务器愿意维持这条连接，在响应消息中也会包含一个Connection: Keep-Alive的头域。同时，可以加入一些指令描述该长连接的属性，如max，timeout等</li><li>通常，HTTP/1.0的Proxy不支持Connection头域，为了不让它们转发可能误导接收者的头域，协议规定所有出现在Connection头域中的头域名都将被忽略</li></ul></li><li>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。</li><li>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</li></ol></li><li><p><strong>消息传递</strong></p><ol><li>HTTP消息中可以包含任意长度的实体，通常它们使用Content-Length来给出消息结束标志。但是，对于很多动态产生的响应，只能通过缓冲完整的消息来判断消息的大小，但这样做会加大延迟。如果不使用长连接，还可以通过连接关闭的信号来判定一个消息的结束。<ol><li>HTTP/1.1中引入了Chunkedtransfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。</li><li>在HTTP/1.0中，有一个Content-MD5的头域，要计算这个头域需要发送方缓冲完整个消息后才能进行。而HTTP/1.1中，采用chunked分块传递的消息在最后一个块（零长度）结束之后会再传递一个拖尾（trailer），它包含一个或多个头域，这些头域是发送方在传递完所有块之后再计算出值的。发送方会在消息中包含一个Trailer头域告诉接收方这个拖尾的存在。</li></ol></li></ol></li><li><p><strong>Host头域</strong></p><ol><li>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li><li>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。</li></ol></li><li><p><strong>内容协商</strong></p><ol><li>为了满足互联网使用不同母语和字符集的用户，一些网络资源有不同的语言版本（如中文版、英文版）。HTTP/1.0定义了内容协商（contentnegotiation）的概念，也就是说客户端可以告诉服务器自己可以接收以何种语言（或字符集）表示的资源。<ol><li>例如如果服务器不能明确客户端需要何种类型的资源，会返回300（Multiple Choices），并包含一个列表，用来声明该资源的不同可用版本，然后客户端在请求消息中包含Accept-Language和Accept-Charset头域指定需要的版本。</li></ol></li></ol></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><p>详解HTTP1.1：<a href="http://imweb.io/topic/554c5879718ba1240cc1dd8a" target="_blank" rel="noopener">http://imweb.io/topic/554c5879718ba1240cc1dd8a</a></p></li><li><p><a href="https://blog.csdn.net/forgotaboutgirl/article/details/6936982" target="_blank" rel="noopener">https://blog.csdn.net/forgotaboutgirl/article/details/6936982</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;前面的系列文章最终感觉有点零散，所以在这里将HTTP1.0和HTTP1.1的一些区别进行说明。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="HTTP" scheme="http://roux.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习（四）——HTTP2.0的新特性</title>
    <link href="http://roux.top/2018/04/21/HTTP%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://roux.top/2018/04/21/HTTP学习（四）/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-04-22T05:46:02.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p>HTTP2.0可以让我们的应用变得更快、更简单、更健壮，让我们在HTTP/1.1时针对TCP协议特性而做的用来提高性能的HACK一笔勾销</p></li><li><p>为了提高应用的性能，降低延迟，我们能做的无外乎2点，要么传输的东西越小越好，要么距离能获得资源的地方越近越好。</p><ul><li>HTTP2的目的：通过支持<strong>多路复用</strong>来提高并行能力，减少因为3次握手等而产生的延迟；通过<strong>压缩HTTP首部</strong>将协议开销降到最低，同时支持请求优先级和服务器推送。</li><li>HTTP2最大的改变：引入<strong>二进制分帧层</strong>。HTTP2.0不会改动HTTP1.x的语义，提供的功能也不变，但是HTTP2对内修改了格式化数据的方式，以及传输这些数据的方式。对外，也就是面向应用，不用做任何改变，感知不到这一层的变化的。</li></ul></li><li><p>其实HTTP2.0是对HTTP1.x的一个扩展，而非替代，之所以称之为2是因为它引入的二进制分帧层之前的HTTP1.x的服务端和客户端并不兼容。</p><a id="more"></a></li></ul><h3 id="特性浅析"><a href="#特性浅析" class="headerlink" title="特性浅析"></a>特性浅析</h3><h4 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a><strong>分帧</strong></h4><ul><li><p>这是HTTP2.0中最大的改变。HTTP2.0之所以性能会比HTTP1.x有那么大的提高，很大程度上正是由于这一层的引入。</p><blockquote><p>这里所谓的“层” ，指的是位于套接字接口[1]与应用可见的高层HTTP API之间的一个新机制:HTTP的语义，包括各种动词、方法、首部，都不受影响，不同的是<strong>传输期间</strong>对它们的编码方式变了。</p></blockquote></li><li><p>HTTP1.x用回车换行符作为纯文本的分隔符，在进行解析和差错检测时不方便。HTTP1.x中用ASCII码，是16进制的，来表示报文中的每一个字符，如下图中,47代表字母G，45代表字符E，54代表字符T。</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/http-header.png" alt=""></p></li><li><p>然而，HTTP2.0引入分帧层后，将报文分隔成一个个更小的帧，并采用二进制编码的方式。通常会将一个消息（首部和数据在一起的）分成一个HEADER帧和若干个DATA帧。如下图所示</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/frame-layer.png" alt=""></p><pre><code>另外需要明确的几个定义： **流**：已建立的连接上的双向字节流。具有唯一的流ID，客户端发起的为奇数ID，服务端发起的为偶数ID。很多个流可以并行的在同一个tcp连接上交换消息。 **消息**：与逻辑消息对应，比如一个请求或一个响应。由一个或多个帧组成。 **帧**：HTTP2中最小的通信单位，每个帧都会有帧首部，每个帧或者用来承载HTTP首部或负荷数据，或其他特定类型的帧。帧是遵循二进制编码的。总得来说，就是这样的，在HTTP2中，相同域名下的所有通信都在一个连接上完成，这个连接中可以承载任意数量的双向流。这些流都是以消息的形式被发送的，同时消息又由一个或多个帧组成。多个帧之间可以乱序发送，最后根据帧首部的流标识重新组装。</code></pre></li><li><p><strong>解释</strong> :这个双向是指，服务器可以给浏览器发消息（server push），浏览器也可以给服务器发东西（这就不用说啦）</p></li></ul><ul><li><p>对于一个帧来说，有固定固定帧格式，其中帧首部规定了帧最多只能带64KB的数据，还包括了帧类型和流标识符等。另外，帧中还可以填充一些额外的数据，最多255字节，保证数据安全性，拿HEADER帧举例。</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/frame-structure.png" alt=""></p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/frame-header.png" alt=""></p></li><li><p>从这点上看，HTTP2.0中的帧与tcp报文段有些相似的。</p><p>在客户端或服务端发起建立新流时，帧携带HTTP的首部块，其中服务端发起流时，发送的HEADER帧没有优先级这一字段；当新流建立之后，就可发送HTTP消息的应用数据，也就是帧的负荷数据。</p><p>将消息拆成多个数据帧之后，会大大缓解HTTP队首阻塞[2]的情况。但是与tcp层的队首阻塞[3]并无直接关系。同时，改以帧为传输单位后，使得对报文无论是解析和差错检测方面都变得更加容易，因为对纯文本的解析还需要考虑到空格，空行，换行等问题。另外，也还消除了并行处理和发送请求及响应时对多个连接的依赖。</p></li><li><p><strong>解释</strong> ：多路复用：用一个tcp连接，并行发好多。【…keep_alive 很像啊】 —分组数？？表示是底层的，都没有概念…按道理说是分帧了后，分组数会变多啊？？？ 和keep_alive 不像，是和管道化很像哈。 实际上是这样的，首先肯定的是多使用同一个tcp连接，比起以前的多个tcp连接，会至少每次少了3个建立连接的tcp报文段，还不包括重传的。同时因为分帧之后出错的概率变小，间接的需要重传的包变少。从这两方面来说整个网络中的包中的总数是变少的。 另外呢，tcp报文段的长度其实还是保持不变的，不同流中的帧其实是混在一个tcp报文段中一起被发送，而在接收方那边接受到这个报文段后再进行拆分重新组装成新的http报文。</p></li></ul><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a><strong>首部压缩</strong></h4><ul><li>由于HTTP协议是一种无状态的协议，服务器自身不会保存太多的信息和先前请求过的元数据信息，这就需要客户端每次都使用多个首部字段来描述所传输的资源及其属性，又由于HTTP1.1是以文本形式传输的，每次都会给HTTP报文增加500-800字节的负荷，如果算上cookie，这个负荷甚至会增加到上千。如果可以有办法减少这些开销，那么对性能又有很大的提升。<ol><li>HTTP2采用HPACK压缩方法，一边用index mapping table压缩，一边编码。这个table由<a href="https://http2.github.io/http2-spec/compression.html#static.table.definition" target="_blank" rel="noopener">静态表</a>和动态表组成。<ol><li>先用预定义的index mapping table将头部中常用的字符串用index来代替</li><li>对一定要使用文本表示的字符串，采用预定义的哈夫曼编码表进行编码 (具体的压缩和解压缩的方法请看<a href="http://www.cnblogs.com/ghj1976/p/4586529.html" target="_blank" rel="noopener">此文</a>的解释)<ul><li>客户端和服务器端使用首部表来跟踪和存储之前发送的每一个键值对。第一次请求时发送过的键值对，第二次在再请求时就不在发送了。（这一现象还一直没观察到）</li><li>在tcp连接期间，客户端和服务端共同维护这个首部表，并且是共同渐进更新的</li><li>每个新的键值对，要么直接添加到首部表尾部，要么替换原有表中的值</li></ul></li></ol></li><li>另外，HTTP2的前身SPDY采用的头部压缩算法是delate算法，这个算法的压缩效率也不错，但是由于存在<a href="http://www.freebuf.com/articles/web/5636.html" target="_blank" rel="noopener">CRIME攻击</a>，而HTTP2不得不重新设计了HPACK算法。</li></ol></li><li><strong>解释</strong> 使用了HPACK算法，一方面如果下一次请求头部和上一次请求头部中有相同的字段，那么相同的字段不会被发送，只会被发送差异性的字段。另一方面，会有一张首部表，里面会有常用的首部字段极其对应的序号，会有序号来代替这个具体的字段字符串。同时，整个首部帧还会用哈夫曼编码来进行压缩。</li></ul><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><strong>多路复用</strong></h4><ul><li><p>引入二进制分帧层之后，HTTP2.0可以很容易的去实现多流并行而不用依赖建立多个tcp连接。</p><blockquote><p>实验表明，客户端使用更少的连接肯定可以降低延迟时间。HTTP 2.0 发送的总分组数量比 HTTP 差不多要少 40%。而服务器处理大量并发连接的情况也变成了可伸缩性问题，因为 HTTP 2.0 减轻了这个负担。 —-HTTP2.0</p></blockquote></li><li><p>每个来源使用一个连接，优势如下：</p><ul><li>从服务器和客户端来说，占用的资源和内存都少了。</li><li>从tcp连接和网络来说，使得网络拥塞得到改善，慢启动时间减少，拥塞和丢包恢复速度变快。</li></ul></li><li><p><strong>解释</strong></p><ul><li>keep-alive，也是可以不进行3次握手就可以发送多个在同一个域下的请求。但是必须发送下一个请求B，等待前一个请求A的响应收到后才可以发送。多路复用和管道优化差不多，只是管道优化由于兼容性的问题，而没有被普遍使用。</li><li>但是什么时候断？如果太多的保持连接，会不会反而不好呢 和一般TCP连接释放一样，如果客户端没有数据要请求，或服务端数据发送完毕后，会主动发送关闭连接的报文。或者是服务端连续发送10个探测报文，客户端无响应，服务端就关闭了这个连接。</li></ul></li></ul><h4 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a><strong>请求优先级</strong></h4><ul><li><p>当同一条连接上可以同时发送很多请求时，并不等于说这些请求对于服务器来说都应该一视同仁，因为客户端对资源的需求程度不同。比如说一个html文档，显然客户端对CSS和JS的需求，远大于对文档内图片的需求。</p><p>因此在建立新流时，HEADER帧可以带有一个优先级(31位，0为优先级最高)的值。这样，服务端就可以因此而适当分配资源，优先发送这些优先级高的帧。</p><p>HTTP2.0协议并没有规定这样的处理优先级的算法该如何实现，仅仅只是提供了这样一种机制。</p><p>为了合理充分利用网络资源，服务器也应该交错处理不同优先级的帧。而不是严格按照优先级来处理，否则又会造成队首堵塞的情况。</p></li><li><p><strong>解释</strong> ：请求优先级….感觉需要服务器也要支持的节奏（那确实变复杂了） 是的。也就是说服务器和客户端对这个优先级的理解是一样的，或是达成一致的。</p></li></ul><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a><strong>服务器推送</strong></h4><ul><li><p>说到服务器推送，其实在HTTP1.1时，我们就用到过类似的，比如将图片使用base64编码嵌入在文档中。</p><p>之所以要提供这个服务，是因为一个文档被请求回来时，往往还需要再次请求很多文档内的其他资源，如果这些资源的请求不用客户端发起，而是服务端提前预判发给客户端，那么就会减少一半的RTT。</p><p>HTTP2.0这个协议也没有规定服务器端到底该怎样推送这个资源。服务端可以自己制定不同的策略，可以是根据客户端明确写出的推送请求；或者是服务端通过学习得来；再或者是通过额外的HTTP首部想服务端表明意向。</p></li><li><p>这个服务的特点是：</p><ul><li>只有建立连接后，服务器才可以推送资源(发送PUSH_PROMISE帧，这个帧中只有要约的HTTP首部)，也就是说服务器不能无缘无故的主动向客户端推送资源</li><li>客户端可以发送RST_STREAM拒绝服务器推送来的资源。但是这可能存在一个时间差，而导致客户端明明已经拒绝了，但服务端却还是把资源推送了过来。</li><li>推送的资源可以有不同页面共享</li><li>服务器可以按照优先级来推送资源</li></ul></li><li><p><strong>解释</strong> 服务器主动推送一个资源，客户端有权来选择是接收还是不接收，不能‘来者不拒’嘛，是吧。</p></li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h4><ul><li>我们知道在HTTP2协议中，我们可以在同一个连接中，建立多个流，那么实际上这些流之间是相互竞争的，会相互争夺这个连接中资源的分配。此时与tcp流量控制相似，我们也需要对流中的帧进行流量控制。但只有DATA帧受流量控制，而其他类型的帧不受流量控制。同样，HTTP2也只提供了这样一种机制，而非具体实现。<ul><li>这个流量控制在没一跳之间进行，而非端到端</li><li>流量控制基于窗口更新帧。连接建立之初，通过交换settings帧，来设定双向的流量控制窗口大小。</li><li>发送端每发送一个DATA帧，就将window的值减去这次data帧的大小，直到window=0。</li><li>接收方可通过发送window_update 帧。如果接收方不想接受数据了，就不发送window _update帧。</li><li>在接受关键资源时，可将非关键资源的window设置的非常小，等网络空闲了，再改回大一些。</li></ul></li></ul><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><ul><li><p>可以使用chrome的工具<code>chrome://net-internals/#http2</code>来查看具体发送的帧的内容</p></li><li><p>打开chrome-network中的protocol一栏，查看当前站点使用的HTTP版本</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/chrome-tool.png" alt=""></p></li><li><p>安装chrome扩展<a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?hl=zh-CN" target="_blank" rel="noopener">HTTP/2 and SPDY indicator</a>,在地址栏右侧会标示出是否使用了HTTP2或SPDY协议。</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/chrome-tool1.png" alt=""></p></li><li><p>在firefox浏览器的网络中，也可直接查看使用的HTTP协议的版本</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/firefox-tool.png" alt=""></p></li><li><p>帮助我们检测某个网站是否使用了HTTP2协议的网站<a href="https://www.h2check.org/" target="_blank" rel="noopener">HTTP/2 Checker</a>;检测是否使用了SPDY协议的网站<a href="https://spdycheck.org/" target="_blank" rel="noopener">SPDYCheck.org</a></p></li><li><p>分析页面性能的网站<a href="http://www.webpagetest.org/" target="_blank" rel="noopener">WebPagetest</a></p></li></ul><h3 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h3><p>为了能够亲自证实HTTP2确实对web性能有了很大的改进，使用nodejs作为服务端，分别验证在使用HTTP2, HTTPS, HTTP和SPDY作为HTTP协议时，同时加载10张图片时web性能的表现，<a href="http://jiaolonghuang.github.io/code/http2-experiment.zip" target="_blank" rel="noopener">代码下载</a>。结果比较出乎意外：</p><ul><li><p>可以比较直观的观察到多路复用的表现</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/http2-e.png" alt=""></p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/http1-e.png" alt=""></p></li><li><p>Server Push的验证 <a href="https://www.imququ.com/" target="_blank" rel="noopener">屈屈</a>的<a href="https://www.imququ.com/post/use-http2-now.html" target="_blank" rel="noopener">博客</a>中有专门的介绍，这里我们也看一下。打开博客首页后可看到响应头中有<code>link:&lt;...&gt;</code>这样一个键值对，这是告诉服务器这个资源需要被推送。</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/server-push.png" alt=""></p><p>然后使用之前提到过的<code>chrome://net-internals/#http2</code>工具来查看具体的Push过程</p><p><img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/four/push_promise.png" alt=""></p></li><li><p>至于头部压缩字节变少，页面加载速度变慢并无明显结果。与<a href="http://www.infoq.com/cn/news/2015/02/https-spdy-http2-comparison" target="_blank" rel="noopener">HTTPS、SPDY和HTTP/2的性能比较</a>的实验结果差的也比较多。</p></li></ul><p>猜测原因：由于是访问的本地资源，不能模拟网络拥塞的情况，故不能完全体现出http2的优势。</p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><ol><li>套接字：是支持TCP/IP网络通信的基本操作单元，可以看成是不同主机之间的进程进行双向通信的端点。是应用进程与tcp连接之间的门，通过套接字口来发送或获得报文。</li><li>HTTP队首阻塞：一个慢请求阻塞后面的所有请求。具体来说就是，假设客户端同时发送2个请求，一个高优先级，一个低优先级，即便低优先级的资源先准备好了，也不会先发送，而是先等着，等高优先级的响应发送完了再发送低优先级的。这样会导致网络资源浪费，服务器缓冲开销浪费，最终导致客户端等待时间无限期延迟。</li><li>tcp队首阻塞：tcp要求分组严格按照顺序交付，一个分组未收到，就会阻塞后续的所有高序号分组。直到重传那个丢失的分组。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HTTP2.0可以让我们的应用变得更快、更简单、更健壮，让我们在HTTP/1.1时针对TCP协议特性而做的用来提高性能的HACK一笔勾销&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了提高应用的性能，降低延迟，我们能做的无外乎2点，要么传输的东西越小越好，要么距离能获得资源的地方越近越好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP2的目的：通过支持&lt;strong&gt;多路复用&lt;/strong&gt;来提高并行能力，减少因为3次握手等而产生的延迟；通过&lt;strong&gt;压缩HTTP首部&lt;/strong&gt;将协议开销降到最低，同时支持请求优先级和服务器推送。&lt;/li&gt;
&lt;li&gt;HTTP2最大的改变：引入&lt;strong&gt;二进制分帧层&lt;/strong&gt;。HTTP2.0不会改动HTTP1.x的语义，提供的功能也不变，但是HTTP2对内修改了格式化数据的方式，以及传输这些数据的方式。对外，也就是面向应用，不用做任何改变，感知不到这一层的变化的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其实HTTP2.0是对HTTP1.x的一个扩展，而非替代，之所以称之为2是因为它引入的二进制分帧层之前的HTTP1.x的服务端和客户端并不兼容。&lt;/p&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="HTTP" scheme="http://roux.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习（五）——HTTP2 VS SPDY</title>
    <link href="http://roux.top/2018/04/21/HTTP%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://roux.top/2018/04/21/HTTP学习（五）/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-04-22T05:45:56.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>SPDY是HTTP2的催化剂，但SPDY不是HTTP2。 本文主要针对SPDY与HTTP2之间的区别，而不太多的涉及它俩之间与HTTP1.X的区别。</li></ul><h3 id="SPDY的出现"><a href="#SPDY的出现" class="headerlink" title="SPDY的出现"></a>SPDY的出现</h3><ul><li><p>SPDY是谷歌在09年年中时发布的，它的主要目标时通过解决HTTP1.1中一些显著的性能限制，来减少网页额的加载时间。目前为止，Chrome,Firefox和Opera都支持了这一协议。</p></li><li><p>SPDY引入了新的二进制分帧层，以实现多路复用、优先次序、最小化的消除网络延迟，同时对HTTP首部进行压缩，减少HTTP报文的冗余数据。</p><blockquote><p>目前为止，我们只在实验室条件下测试过 SPDY。最初的成果很激动人心：通过模拟的家庭上网线路下载了 25 个最流行的网站之后，我们发现性能的改进特别明显，页面加载速度最多快了 55%。 ——A 2x Faster Web Chromium Blog</p></blockquote></li></ul><a id="more"></a><ul><li><p>一方面由于随着web应用的发展，HTTP1.1协议的局限性突显的越来越严重，另一方面由于SPDY的优秀表现，12年初，W3C向全社会征集HTTP2的建议，最终决定将SPDY规范作为制定标准的基础。随后的时间内，SPDY与HTTP2共同进化，HTTP2提出新规范或新功能，SPDY为它进行测试和验证。当HTTP2一切就绪之日，就是SPDY退出舞台之时。事实上，在今年2月谷歌公司已经宣布将在16年年初放弃对SPDY的支持。</p></li><li><p>目前各浏览器对SPDY和HTTP2的支持情况分别如下:<br>  <img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/five/spdy-caniuse.png" alt=""><br>  <img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/five/http2-caniuse.png" alt=""></p><h3 id="SPDY与HTTP2的区别"><a href="#SPDY与HTTP2的区别" class="headerlink" title="SPDY与HTTP2的区别"></a>SPDY与HTTP2的区别</h3></li><li><p>头部压缩算法，SPDY，通用的deflate算法[注1]；HTTP2，专门为压缩头部设计的HPACK算法</p></li><li>SPDY必须在TLS上运行，HTTP2可在TCP上直接使用，因为增加了HTTP1.1的Upgrade机制</li><li>更加完善的协议商讨和确认流程</li><li>更加完善的Server Push流程</li><li>增加控制帧的种类，并对帧的格式考虑的更细致</li></ul><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><ul><li><p>deflate算法 这个算法是由2个算法组合而成，哈夫曼编码和LZ77编码。</p><ul><li><p>哈夫曼编码 一种无前缀编码，简单来说就是长字符串用短编码表示，以最终达到减少总大小的目的。具体编码过程可参考Huffman 编码压缩算法</p></li><li><p>例如，在一篇英语文章中，字母“E”出现的频率最高，“Z”最低，如果我们采用字符编码，那么每一个字母都是8bit表示；但是如果，我们使用不定长的bit编码，频率高的字母用比较短的编码表示，频率低的字母用长的编码表示，就会大大缩小文件的空间。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">字符编码</span><br><span class="line">A00101001</span><br><span class="line">B00101010</span><br><span class="line">C00101011……</span><br><span class="line">哈夫曼编码</span><br><span class="line">A    <span class="number">0</span></span><br><span class="line">B    <span class="number">10</span></span><br><span class="line">C    <span class="number">110</span></span><br><span class="line">D    <span class="number">1110</span></span><br><span class="line">E    <span class="number">11110</span></span><br></pre></td></tr></table></figure><p>大致思路：每次总是选取频率最小两个节点，将其频率相加，最终构成一个最优二叉树。 例如：有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1,那么我们第一步先取两个最小权值作为左右子树构造一个新树，即取1，2构成新树，其结点为1+2=3<br>  <img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/five/hfm-1.png" alt=""><br>虚线为新生成的结点，第二步再把新生成的权值为3的结点放到剩下的集合中，所以集合变成{5,4,3,3}，再根据第二步，取最小的两个权值构成新树，如图：<br>  <img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/five/hfm-2.png" alt=""><br>再依次建立哈夫曼树:<br>  <img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/five/hfm-3.png" alt=""><br>其中各个权值替换对应的字符即为下图:<br>  <img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/five/hfm-4.png" alt=""><br>所以各字符对应的编码为：A-&gt;11,B-&gt;10,C-&gt;00,D-&gt;011,E-&gt;010</p></li><li><p>LZ77编码 字典压缩算法,用到的场景比如gzip。</p><ul><li><p>这个算法的主要思想是：文件中有两块内容相同的话，那么只要知道前一块的位置和大小，我们就可以确定后一块的内容。所以我们可以用（两者之间的距离，相同内容的长度）这样一对信息，来替换后一块内容。由于（两者之间的距离，相同内容的长度）这一对信息的大小，小于被替换内容的大小，所以文件得到了压缩。</p></li><li><p>大致流程如下： 可构想出2个窗口，一个作为搜索缓存区（已完成搜索的字符），一个作为待搜索窗口。如下图:<br>  <img src="https://raw.githubusercontent.com/paulRoux/Pictures/master/HTTP/five/lz77.jpg" alt=""></p></li><li>编码过程：<ul><li>如果待搜索字符c没在搜索缓存区中找到，则输出(0,0,c),同时，整个窗口向前移动1位</li><li>如果待搜索字符c在搜索缓存区中找到，起始位置在搜索缓存区中x，连续长度是offset，待搜索窗口中offset之后的一个字符是d，则输出(x, offset, d)。之后，整个窗口向前移动offset位。</li><li>最终输出的三元组就是压缩码</li></ul></li></ul></li></ul></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://imjiaolong.cn/post/http2%26spdy.html" target="_blank" rel="noopener">https://imjiaolong.cn/post/http2%26spdy.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;SPDY是HTTP2的催化剂，但SPDY不是HTTP2。 本文主要针对SPDY与HTTP2之间的区别，而不太多的涉及它俩之间与HTTP1.X的区别。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;SPDY的出现&quot;&gt;&lt;a href=&quot;#SPDY的出现&quot; class=&quot;headerlink&quot; title=&quot;SPDY的出现&quot;&gt;&lt;/a&gt;SPDY的出现&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SPDY是谷歌在09年年中时发布的，它的主要目标时通过解决HTTP1.1中一些显著的性能限制，来减少网页额的加载时间。目前为止，Chrome,Firefox和Opera都支持了这一协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SPDY引入了新的二进制分帧层，以实现多路复用、优先次序、最小化的消除网络延迟，同时对HTTP首部进行压缩，减少HTTP报文的冗余数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前为止，我们只在实验室条件下测试过 SPDY。最初的成果很激动人心：通过模拟的家庭上网线路下载了 25 个最流行的网站之后，我们发现性能的改进特别明显，页面加载速度最多快了 55%。 ——A 2x Faster Web Chromium Blog&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP学习（一）——HTTP的历史</title>
    <link href="http://roux.top/2018/04/20/HTTP%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://roux.top/2018/04/20/HTTP学习（一）/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-22T05:44:00.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>本系列文章均转自<a href="https://imjiaolong.cn/" target="_blank" rel="noopener">小路口</a>的系列博文，因为没有找到博主的联系方式，故如有侵权烦请联系我进行处理。</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>在上世纪60年代，世界上占统治地位的通信网络是电话网络，它是基于电路交换[1]的。与此同时，随着分时计算机的出现和计算机重要性的提高，如何充分利用分散在世界各地的数字计算机为人们所共享就变的越发重要了。其中需要注意的是，这些用户所产生的流量是具有突发性的，也就是说具有活动的间断性。</li><li>于是世界上的科学家们就发明了更能很好解决突发性的分组交换来替代电路交换。最开始是美国的阿帕网，ARPAnet，是世界上第一个分组交换机网络，也就是今天因特网的直接祖先。</li><li>HTTP协议是现代web的基础。其实HTTP协议的出现主要是为了推动万维网的应用，它们的发明者是同一个人。HTTP协议设计之初是非常简洁的，就是为了传输超文本文档，也就是HTTP0.9版本。</li></ul><a id="more"></a><h3 id="HTTP的版本"><a href="#HTTP的版本" class="headerlink" title="HTTP的版本"></a>HTTP的版本</h3><ul><li><p>HTTP0.9</p><ul><li>请求：ASCII字符串＋CRLF结尾</li><li>响应：ASCII字符流/HTML+CRLF结尾</li><li>只能GET获取资源，不能发送携带数据的POST请求</li><li>文档传完之后，断开连接</li></ul></li><li><p>HTTP1.0（并不是真正的规范）</p><p>随着页面上的内容逐渐丰富，除了文字，超链接，还有图片资源。 人们对web应用的需求也不断增加，要求不仅能够访问HTML同时还需要能够提供有关请求和响应的元数据（首部字段），在页面上进行交互操作，比如表单提交，并且支持内容协商。</p><ul><li>请求/响应的首部可有多行首部字段构成</li><li>响应对象前增加了一个响应状态行</li><li>可以支持长连接，还是每次请求结束后默认都断开连接</li></ul></li><li><p>HTTP1.1</p><ul><li>持久连接</li><li>分块传输</li><li>字节范围请求</li><li>协商机制更健全，协商内容更多：内容编码，传输编码，缓存指令，客户端cookie等</li><li>HTTP pipling(实际使用受限，浏览器默认不开启，很多中间代理不提供该服务)</li></ul></li><li><p>HTTP2 在web应用中资源越来越丰富的趋势中，由于tcp自身的特点以至于HTTP1.1的性能上受到了很大的限制，虽然我们有做一些针对性能提高的hack。HTTP2的出现主要是为了提高传输性能，降低延迟，提高吞吐量。</p></li></ul><p>从总体来说，HTTP0.9用了一行命令就启动了万维网，HTTP1.0是对0.9扩展的正式说明，而HTTP1.1则是一份官方标准。总之，HTTP1.x的设计的初衷是实现要简单。但是这也是以牺牲性能为代价的。所以，这也是现在HTTP2所要解决的问题。</p><ul><li><strong>解释</strong><ol><li>“HTTP1.x的设计的初衷是实现要简单。但是这也是以牺牲性能为代价的” 比如没有处理并行连接和请求的快捷方法，没有为了减少不必要的请求开销而做优化（首部压缩）等等，这些以至于在页面资源极其丰富的今天，即便我们针对HTTP1.1做了很多HACK优化，然而性能还是没有得到很大的提升。而这些点在HTTP2中都得到了改进。</li></ol></li></ul><h3 id="HTTP与tcp的关系"><a href="#HTTP与tcp的关系" class="headerlink" title="HTTP与tcp的关系"></a>HTTP与tcp的关系</h3><ul><li>HTTP是应用层的协议，tcp是传输层的协议。HTTP协议并没有规定必须要使用tcp协议当作是传输层的协议，现在默认使用tcp当做是传输层协议，采用80端口（因为HTTP是无状态协议，要是使用未经改良的不可靠传输协议，很容易造成数据丢失）；另外，谷歌还研发了一种基于udp的多路传输协议QUIC(Quick UDP Internet Connections)[2]，用来解决SPDY在TCP遇到的瓶颈而在UDP上做出的探索。</li><li>HTTP是一种无状态的协议，当前的请求与上一次的请求并无关系，也就是说这次HTTP请求做什么和上一次请求做什么是没有关系的，哪怕请求的是相同的资源。这样做的好处是，服务器不用为了保存状态而消耗过多的资源，坏处是重复发相同的状态，会浪费网络资源，造成网络拥塞，延迟增大。</li><li>tcp提供了可靠传输的性能，为精确传输做了优化，比如3次握手，差错检测，快速重传。同时还进行了拥塞预防与控制，慢启动等来减轻整个网络的拥塞程度。一个数据包从请求到收到，需要经过传播延迟，传输延迟，处理延迟和排队延迟。因此，tcp比较适合大块数据的精确传输，性价比高；若常有突发的连接请求，实际上是其负作用的。原因很简单，在拿到完整数据之前，tcp做了太多事，造成了太多延迟，至少1个RTT。</li></ul><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><ol><li>电路交换：在端系统会话过程中，预留了端系统间所经路径所需要的资源，包括缓存，链路传输速率。</li><li>QUIC能够处理传输可靠性、丢包或无序数据包等一系列UDP默认未处理的问题。它的高层类似SPDY，低层是在UDP上模仿实现TCP的面向连接特性和可靠性并加入类似TLS的加密过程</li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://imjiaolong.cn/post/http-history.html" target="_blank" rel="noopener">https://imjiaolong.cn/post/http-history.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本系列文章均转自&lt;a href=&quot;https://imjiaolong.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小路口&lt;/a&gt;的系列博文，因为没有找到博主的联系方式，故如有侵权烦请联系我进行处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在上世纪60年代，世界上占统治地位的通信网络是电话网络，它是基于电路交换[1]的。与此同时，随着分时计算机的出现和计算机重要性的提高，如何充分利用分散在世界各地的数字计算机为人们所共享就变的越发重要了。其中需要注意的是，这些用户所产生的流量是具有突发性的，也就是说具有活动的间断性。&lt;/li&gt;
&lt;li&gt;于是世界上的科学家们就发明了更能很好解决突发性的分组交换来替代电路交换。最开始是美国的阿帕网，ARPAnet，是世界上第一个分组交换机网络，也就是今天因特网的直接祖先。&lt;/li&gt;
&lt;li&gt;HTTP协议是现代web的基础。其实HTTP协议的出现主要是为了推动万维网的应用，它们的发明者是同一个人。HTTP协议设计之初是非常简洁的，就是为了传输超文本文档，也就是HTTP0.9版本。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="HTTP" scheme="http://roux.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习（三）——关于HTTP/1.1的管道化</title>
    <link href="http://roux.top/2018/04/20/HTTP%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://roux.top/2018/04/20/HTTP学习（三）/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-12-14T13:55:33.375Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是http管道化"><a href="#什么是http管道化" class="headerlink" title="什么是http管道化"></a>什么是http管道化</h3><ul><li>通常，http请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。 </li><li>HTTP/1.1允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。（me：所有请求保持一个FIFO的队列，一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出；同时，服务器端返回这些请求的响应时也是按照FIFO的顺序）。<ul><li>管道化的表现可以大大提高页面加载的速度，尤其是在高延迟连接中。 管道化同样也可以减少tcp/ip的数据包。通常MSS的大小是在536-1460字节，所以将许多个http请求放在一个tcp/ip包 里也是有可能的。减少加载一个网页所需数据包的数量可以在整体上对网络有益处，因为数据包越少，路由器和网络带来的负担就越少。</li><li>HTTP/1.1需要服务器也支持管道化。但这并不意味着服务器需要管道化响应，而是当客户端发出管道化请求时，服务器不会响应失败。这显然有可能引入一种新的福音主义错误（原文：This obviously has the potential to introduce a new category of evangelism bugs），因为仅有现代浏览器支持管道化。</li></ul></li></ul><a id="more"></a><h3 id="什么时候我们应该管道化请求"><a href="#什么时候我们应该管道化请求" class="headerlink" title="什么时候我们应该管道化请求"></a>什么时候我们应该管道化请求</h3><ul><li>只有幂等的请求[1] 才可以被管道化，比如GET和HEAD。POST和PUT不应该被管道化。我们同样也不应该在建立新连接的时候发出管道化的请求 ，因为不能确源服务或代理是否支持HTTP/1.1。因此，管道化只能利用已存在的 keep-alive 连接。</li></ul><h3 id="多少个请求应该被管道化"><a href="#多少个请求应该被管道化" class="headerlink" title="多少个请求应该被管道化"></a>多少个请求应该被管道化</h3><ul><li>如果连接过早的关闭，管道化许多请求是划不来的，因为我们会花费很多时间用来向网络里写请求，然后还不得不在新连接中重写一遍。而且，如果较早到达的请求需要花费很长的时间完成，一个过长的管道实际上会让用户感知到更长的延迟。</li><li>HTTP/1.1标准也没有提供关于管道化请求理想数目的任何指导。实际上，我们建议每个服务器不超过2个keep-alive连接。显然，这个还得依赖于应用本身。鉴于上述的原因，浏览器可能不需要一个持续时间特别长的管道。2个可能是比较合适的值，但是还有待测试。</li></ul><h3 id="如果一个请求被取消了，会发生什么？"><a href="#如果一个请求被取消了，会发生什么？" class="headerlink" title="如果一个请求被取消了，会发生什么？"></a>如果一个请求被取消了，会发生什么？</h3><ul><li>如果一请求被取消了，是不是意味着整个管道都被取消了呢？或者，是不是意味着这个被取消请求的响应应该被简单的丢弃，以便这个管道中的其他请求不会被强制重发？<ul><li>这个答案依赖于很多因素，包括，这个被取消请求的响应还有多少没有被收到。最原始的办法可能是简单的取消管道，然后重发所有的请求。仅仅当请求是幂等的时候才可以。这样原始的方法也可以产生好的影响，因为正在管道中被发送的请求可能属于同一个正在被取消的页面载入组。</li></ul></li></ul><h3 id="如果连接失败会发生什么？"><a href="#如果连接失败会发生什么？" class="headerlink" title="如果连接失败会发生什么？"></a>如果连接失败会发生什么？</h3><ul><li>如果连接失败了或服务器在下载一个管道中的响应时中断了，浏览器必须有能力重新开始发送被丢失的请求。这种情况可以等同于上面讨论的被取消的例子。</li></ul><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li>其实HTTP管道化就是将客户端的FIFO队列移到了服务端。在客户端可以依次发送所有要发送的请求（当然这些请求是在同一个域下的），一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出。在服务器端维持的FIFO队列，这个队列是按照资源的重要程度排列的。比如HTML比CSS要先返回，JS,CSS比图片先返回。</li><li>在服务器端会有一个缓冲区，来存放那些已经被处理好了但是还没轮到被发送的响应。比如服务器先后收到了A,B两个请求，A资源比B资源优先级要高，处理A需要10ms，处理B需要1ms，假设服务器可以并行处理请求，那么B的响应肯定是最先处理好了的，但是B响应不能先发出去，必须待在缓冲区里，等待A响应处理好了之后，先把A的响应发出去，B的响应才能够被发出去。因为服务端必须要遵循FIFO这个原则。</li><li>HTTP管道化不是HTTP2的内容，是对HTTP1.1协议下，服务器不能很好处理并行请求的一个改进。</li><li>管道化的有序和TCP的有序是本质上的不同，管道化的有序，是消息与消息之间的有序。TCP中的有序，组成一个消息的多个报文段之间的有序。</li><li>管道做了哪些事，我的理解是创造了一个可以不用等待前一个请求的响应即可发送下一个请求的场所。至于注意些什么，除了知道有些设备不支持，其他的我也没实际经验（毕竟没用过，囧）。</li></ol><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><ol><li><strong>HTTP/方法的幂等性</strong>：是指一次和多次请求某一个资源应该具有同样的副作用。 幂等性的请求，实际上就是多次操作都不会改变结果的请求，比如GET，我可以多次从同一个地方获取资源，但是对于资源本身来说并不会发生什么变化，我GET10次和GET100次，资源都没有发生任何变化。而post则不同了，我提交表单10次，和100次，造成的结果是不同的，至少数据库里新增的数据有不同。<ul><li>详情见<a href="https://www.jianshu.com/p/475589f5cd7b" target="_blank" rel="noopener">此文</a></li></ul></li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://imjiaolong.cn/post/http-pipelining.html" target="_blank" rel="noopener">https://imjiaolong.cn/post/http-pipelining.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是http管道化&quot;&gt;&lt;a href=&quot;#什么是http管道化&quot; class=&quot;headerlink&quot; title=&quot;什么是http管道化&quot;&gt;&lt;/a&gt;什么是http管道化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通常，http请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。 &lt;/li&gt;
&lt;li&gt;HTTP/1.1允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。（me：所有请求保持一个FIFO的队列，一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出；同时，服务器端返回这些请求的响应时也是按照FIFO的顺序）。&lt;ul&gt;
&lt;li&gt;管道化的表现可以大大提高页面加载的速度，尤其是在高延迟连接中。 管道化同样也可以减少tcp/ip的数据包。通常MSS的大小是在536-1460字节，所以将许多个http请求放在一个tcp/ip包 里也是有可能的。减少加载一个网页所需数据包的数量可以在整体上对网络有益处，因为数据包越少，路由器和网络带来的负担就越少。&lt;/li&gt;
&lt;li&gt;HTTP/1.1需要服务器也支持管道化。但这并不意味着服务器需要管道化响应，而是当客户端发出管道化请求时，服务器不会响应失败。这显然有可能引入一种新的福音主义错误（原文：This obviously has the potential to introduce a new category of evangelism bugs），因为仅有现代浏览器支持管道化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="HTTP" scheme="http://roux.top/tags/HTTP/"/>
    
  </entry>
  
</feed>
