<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shirsen’s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://roux.top/"/>
  <updated>2019-07-05T04:40:06.226Z</updated>
  <id>http://roux.top/</id>
  
  <author>
    <name>Shirsen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的大学啊</title>
    <link href="http://roux.top/2019/07/05/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E5%95%8A/"/>
    <id>http://roux.top/2019/07/05/我的大学啊/</id>
    <published>2019-07-04T16:00:00.000Z</published>
    <updated>2019-07-05T04:40:06.226Z</updated>
    
    <content type="html"><![CDATA[<h4 id="我的大学啊"><a href="#我的大学啊" class="headerlink" title="我的大学啊"></a>我的大学啊</h4><p>&emsp;&emsp;2015到2019年，四年的时光匆匆而逝，白驹过隙般。回顾这四年，收获了很多， 也留下了那么多的遗憾！</p><a id="more"></a><p>&emsp;&emsp;大一大二这两年，虽然时间尽在和小伙伴们的游戏中流逝，但却收获了最多的快乐。唯一觉得美中不足的就是没有多和小伙伴们出去游玩。也许就是缘分吧，让我在大学半数时光快要结束的时候认识了那些牛逼的人，也找到了一路上志同道合的人儿。<br>&emsp;&emsp;怀念那些一起努力学习，一起为了目标奋斗的日子。所有日子的点点滴滴串成我的大三生活，所有的努力在那些迷茫的日子里指引着我们前行，期待着，东升的初阳。<br>&emsp;&emsp;大四一年做的最多的便是积累和沉淀。我一直坚信“知识在于积累，更在于沉淀”，所以在这一年我读了更多的“书”，看了更多的“人和事”。我不知道它们会不会有用上的一天，但我知道它们是我的隐形财富。<br>&emsp;&emsp;四年走来，很开心我遇到了我的一群“儿子们”。那些吹过的牛皮、各自的小秘密、心酸与难过，都会记得。希望往后我们的时间单位不会以“年”来算。<br>&emsp;&emsp;大学这趟旅程，我错过了很多，但不是每次旅程都有返程票。人生里看似偶然却又必经的告别，如约而至，无人可免。感谢那些让我痛或暖，让我快乐也让我难过的人儿，都是珍藏在回忆里的温暖，感谢一路上有你们！如今北上已找到一个小窝，一群小伙伴，充满期待。我爱母校，那座城，那些人。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;我的大学啊&quot;&gt;&lt;a href=&quot;#我的大学啊&quot; class=&quot;headerlink&quot; title=&quot;我的大学啊&quot;&gt;&lt;/a&gt;我的大学啊&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;2015到2019年，四年的时光匆匆而逝，白驹过隙般。回顾这四年，收获了很多， 也留下了那么多的遗憾！&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://roux.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://roux.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔2019-06-02</title>
    <link href="http://roux.top/2019/06/02/%E9%9A%8F%E7%AC%942019-06-02/"/>
    <id>http://roux.top/2019/06/02/随笔2019-06-02/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-06-02T13:07:18.286Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>关于视频行业的胡思乱想</li></ul><a id="more"></a><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>&emsp;&emsp;近几年来，国内视频业的发展依旧不是那么的乐观。身边的人怪广电的还是比较多的，我个人觉得，这个锅不能全让广电背。没出现好的作品，这个固然有以前广电方面的监管审查，导致导演与编剧都不敢过于发挥，但如果广电放松了监管，作品的质量也好不到哪去，说不定好的更好，烂的更烂，原因还是在于导演和编剧本身。一想到手撕鬼子，被强暴后才勇猛的这些作品，我真的觉得智商受到了侮辱。真的是林子大了，什么鸟都有。还有一点就是人民的素质需要提升。<br>&emsp;&emsp;去年和今年，出了几部还不错的作品，是一个不小的进步。后面随着5G技术的普及，人民素质和消费水平的提高，国家监管的放松，应该会有更多优秀的作品呈现给大家。同时，各大视频平台也会得到一个快速的发展，但是这个时间不会太短，还是需要长期来看。<br>&emsp;&emsp;根据我的一些了解来看，目前受大家欢迎的作品主要类型还是爆米花、现实、科幻、讽刺这些。国内估计还会持续很长时间古装、穿越等类型，在新类型的探索上我觉得还有很大的空间。就目前来看视频行业还有很长的路要走。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;关于视频行业的胡思乱想&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="生活" scheme="http://roux.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://roux.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>那些忧伤的年轻人</title>
    <link href="http://roux.top/2019/06/01/%E9%82%A3%E4%BA%9B%E5%BF%A7%E4%BC%A4%E7%9A%84%E5%B9%B4%E8%BD%BB%E4%BA%BA/"/>
    <id>http://roux.top/2019/06/01/那些忧伤的年轻人/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-01T13:54:59.346Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>其实，每一代人的青春都有相通的地方，他们的迷茫、彷徨和忧伤。</li></ul><a id="more"></a><h4 id="那些忧伤的年轻人"><a href="#那些忧伤的年轻人" class="headerlink" title="那些忧伤的年轻人"></a>那些忧伤的年轻人</h4><p>&emsp;&emsp;起初看到这本书，就像是发现了不一样的“蓝天”一般，一瞬间就被他的名字所吸引。这本书，读时也许会觉得写的挺杂乱的，读完回想一番就会明了其实一直在说一件事——“青春”。<br>&emsp;&emsp;其实我们不难发现：每个年代，都会有“那些忧伤的年轻人”在路上，迷茫、彷徨。这就如同“轮回”一样，不变的是这个过程，变得只是每一代的迷茫与彷徨。这一代的我们，也被称作“最幸福”的一代，却一直在“流浪”，身体和心灵尽无处安放。我们接受更好的教育，也目睹着大学沦为“工厂”；我们追逐风口，也被割了一季又一季；我们那些无从说起的忧伤，也只能藏了又藏。<br>&emsp;&emsp;我不喜欢定义或是去概括一个时代，这样显得过于草率与无知。年轻人的忧伤也是如此，三两句话，是无法明了的，因为那可是我们的“青春”啊！“青春”这个词代表了太多太多的东西，对一切幻想，也对一切迷茫，见证着我们的成长。大学里的日子，荒废了太多的时光，用来打游戏或是无所事事。还好一切领悟的都不太晚，现在还能保持一丝“轻狂”，还愿意去反抗。以后再来看现在的一切，<a href="https://music.163.com/#/song?id=1305960097" target="_blank" rel="noopener">我还年轻</a>，也许就是最好的解释。</p><h4 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h4><p><a href="https://book.douban.com/subject/6802373/" target="_blank" rel="noopener">那些忧伤的年轻人</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;其实，每一代人的青春都有相通的地方，他们的迷茫、彷徨和忧伤。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="文学" scheme="http://roux.top/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="观后感" scheme="http://roux.top/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy中的get与extract系列函数</title>
    <link href="http://roux.top/2019/05/31/Scrapy%E4%B8%AD%E7%9A%84get%E4%B8%8Eextract/"/>
    <id>http://roux.top/2019/05/31/Scrapy中的get与extract/</id>
    <published>2019-05-30T16:00:00.000Z</published>
    <updated>2019-06-02T06:00:42.245Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在使用<code>Scrapy</code>框架爬取页面数据的时候经常会出现数据获取不到或者数据并非想要的数据，于是对这里面的<code>get()</code>、<code>getall()</code>、<code>extract()</code>、<code>extract_first()</code>函数的使用进行记录。</li></ul><a id="more"></a><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li><p>一般使用<code>response.xpath()</code>解析得到的是一个<code>SelectorList</code>列表，可以使用<code>type（response.xpath()）</code>查看。<code>SelectorList</code>里面存放的是多个<code>Selector</code>对象。</p><ul><li><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scrapy shell http://www.baidu.com</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = response.xpath(<span class="string">"//span//input/@value"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[&lt;Selector xpath=<span class="string">'//span//input/@value'</span> data=<span class="string">''</span>&gt;, &lt;Selector xpath=<span class="string">'//span//input/@value'</span> data=<span class="string">'百度一下'</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(res)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">scrapy</span>.<span class="title">selector</span>.<span class="title">unified</span>.<span class="title">SelectorList</span>'&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>对于<code>SelectorList</code>，<code>getall()</code>与<code>extract()</code>函数会得到所有的数据，包括制表符和换行符等。<code>get()</code>和<code>extract_first()</code>都会获得列表第一个元素的数据。</p><ul><li><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.get()</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(res.get())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>.<span class="title">getall</span><span class="params">()</span></span></span><br><span class="line">['', '百度一下']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(res.getall())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>.<span class="title">extract</span><span class="params">()</span></span></span><br><span class="line">['', '百度一下']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(res.extract())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>.<span class="title">extract_first</span><span class="params">()</span></span></span><br><span class="line"><span class="class">''</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(res.extract_first<span class="params">()</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>对于<code>Selector</code>，<code>getall()</code>与<code>extract()</code>函数会得到所有的数据(一个元素的情况下，<code>getall()</code>得到的是一个列表，<code>extract()</code>得到的是字符串。多个元素都是列表)。<code>get()</code>会获得元素的数据，<code>extract_first()</code>会出错。</p><ul><li><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(res[<span class="number">1</span>])</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">scrapy</span>.<span class="title">selector</span>.<span class="title">unified</span>.<span class="title">Selector</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>[1].<span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="class">'百度一下'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(res[<span class="number">1</span>].get<span class="params">()</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>[1].<span class="title">getall</span><span class="params">()</span></span></span><br><span class="line"><span class="class">['百度一下']</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(res[<span class="number">1</span>].getall<span class="params">()</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>[1].<span class="title">extract</span><span class="params">()</span></span></span><br><span class="line"><span class="class">'百度一下'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(res[<span class="number">1</span>].extract<span class="params">()</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>[1].<span class="title">extract_first</span><span class="params">()</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">File <span class="string">"&lt;console&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Selector'</span> object has no attribute <span class="string">'extract_first'</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>对于<code>scrapy.selector.unified.SelectorList</code>对象，<code>getall() == extract()</code>返回字符串, <code>get() == extract_first()</code>返回列表。</li><li>对于<code>scrapy.selector.unified.Selector</code>对象， <code>get() != extract_first()</code>,<code>getall()与extract()看元素个数多少</code></li></ul><h4 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h4><ul><li><a href="https://docs.scrapy.org/en/latest/topics/selectors.html" target="_blank" rel="noopener">官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在使用&lt;code&gt;Scrapy&lt;/code&gt;框架爬取页面数据的时候经常会出现数据获取不到或者数据并非想要的数据，于是对这里面的&lt;code&gt;get()&lt;/code&gt;、&lt;code&gt;getall()&lt;/code&gt;、&lt;code&gt;extract()&lt;/code&gt;、&lt;code&gt;extract_first()&lt;/code&gt;函数的使用进行记录。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Others" scheme="http://roux.top/categories/Others/"/>
    
    
      <category term="Function" scheme="http://roux.top/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>pymongo使用</title>
    <link href="http://roux.top/2019/05/17/pymongo%E4%BD%BF%E7%94%A8/"/>
    <id>http://roux.top/2019/05/17/pymongo使用/</id>
    <published>2019-05-16T16:00:00.000Z</published>
    <updated>2019-05-31T16:35:31.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>最近做毕设用到pymongo，对平常的使用记录一下。</li></ul><a id="more"></a><h4 id="pymongo"><a href="#pymongo" class="headerlink" title="pymongo"></a>pymongo</h4><ul><li><p><strong>配置环境</strong></p><ul><li><code>python3.6</code>，<code>pymongo</code>，<code>MongoDB数据库</code> </li><li>数据库配置：<ul><li><strong>uri</strong>：<code>localhost:27017</code></li><li><strong>db</strong>：<code>douban</code></li><li><strong>collection</strong>：<code>human</code></li></ul></li></ul></li><li><p><strong>连接MongoDB</strong></p><ul><li>连接MongoDB我们需要使用PyMongo库里面的MongoClient，一般来说传入MongoDB的IP及端口即可，第一个参数为地址host，第二个参数为端口port，端口默认是27017。</li><li><p>代码：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</span><br><span class="line"><span class="comment"># 或者如下</span></span><br><span class="line">client = pymongo.MongoClient(<span class="string">'mongodb://localhost:27017'</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>指定数据库</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db = client.douban</span><br><span class="line">db = client[<span class="string">'douban'</span>]</span><br><span class="line"><span class="comment"># 上面两种方式是等价的</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指定集合</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collection = db.peoples</span><br><span class="line">collection = db[<span class="string">'peoples'</span>]</span><br><span class="line"><span class="comment"># 上面两种方式是等价的</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>插入数据(以字典的形式表示)</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在PyMongo <span class="number">3.</span>X版本中，insert()方法官方已经不推荐使用</span><br><span class="line">people = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'roux'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'sex'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert(people)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 在MongoDB中，每条数据其实都有一个_id属性来唯一标识，如果没有显式指明_id，MongoDB会自动产生一个ObjectId类型的_id属性</span></span><br><span class="line"><span class="comment"># insert()方法会在执行后返回的_id值</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时插入多条数据，只需要以列表形式传递即可，示例如下：</span></span><br><span class="line"></span><br><span class="line">people1 = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'roux'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'sex'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">people2 = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'shirsen'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'sex'</span>: <span class="string">'female'</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert([people1, people2])</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 返回的结果是对应的_id的集合</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方推荐使用insert_one()和insert_many()方法将插入单条和多条记录分开。</span></span><br><span class="line"></span><br><span class="line">people = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'roux'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'sex'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = collection.insert_one(people)</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_id)</span><br><span class="line"><span class="comment"># 返回结果和insert()方法不同，这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取_id。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于insert_many()方法，我们可以将数据以列表形式传递即可，示例如下：</span></span><br><span class="line"></span><br><span class="line">people1 = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'roux'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'sex'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people2 = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'shirsen'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'sex'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = collection.insert_many([people1, people2])</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_ids)</span><br><span class="line"><span class="comment"># insert_many()方法返回的类型是InsertManyResult，调用inserted_ids属性可以获取插入数据的_id列表</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查询</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'shirsen'</span>&#125;)</span><br><span class="line">print(type(result))</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 在这里我们查询name为shirsen的数据，它的返回结果是字典类型</span></span><br><span class="line"><span class="comment"># 可以发现它多了一个_id属性，这就是MongoDB在插入的过程中自动添加的。</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们也可以直接根据ObjectId来查询，这里需要使用bson库里面的ObjectId。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line"></span><br><span class="line">   result = collection.find_one(&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'593278c115c2602667ec6bae'</span>)&#125;)</span><br><span class="line">   print(result)</span><br><span class="line">   <span class="comment"># 其查询结果依然是字典类型</span></span><br><span class="line">   <span class="comment"># 如果查询_id':结果不存在则会返回None。</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于多条数据的查询，我们可以使用find()方法，例如在这里查找年龄为20的数据</span></span><br><span class="line"></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;)</span><br><span class="line">print(results)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    print(result)</span><br><span class="line"><span class="comment"># 返回结果是Cursor类型，相当于一个生成器，我们需要遍历取到所有的结果，每一个结果都是字典类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要查询年龄大于20的数据，则写法如下：</span></span><br><span class="line"></span><br><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 在这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号$gt，意思是大于，键值为20，这样便可以查询出所有年龄大于20的数据。</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较符号归纳如下表：</span></span><br><span class="line"></span><br><span class="line">符号含义示例</span><br><span class="line">$lt 小于: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">$gt 大于: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">$lte 小于等于: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$lte'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">$gte 大于等于: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gte'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">$ne 不等于: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$ne'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">$<span class="keyword">in</span> 在范围内: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$in'</span>: [<span class="number">20</span>, <span class="number">23</span>]&#125;&#125;</span><br><span class="line">$nin 不在范围内: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$nin'</span>: [<span class="number">20</span>, <span class="number">23</span>]&#125;&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另外还可以进行正则匹配查询，例如查询名字以M开头的学生数据，示例如下：</span></span><br><span class="line"></span><br><span class="line">results = collection.find(&#123;<span class="string">'name'</span>: &#123;<span class="string">'$regex'</span>: <span class="string">'^M.*'</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 在这里使用了$regex来指定正则匹配，^M.*代表以M开头的正则表达式，这样就可以查询所有符合该正则的结果。</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 功能符号归类如下：</span></span><br><span class="line"></span><br><span class="line">符号含义示例示例含义</span><br><span class="line">$regex 匹配正则: &#123;<span class="string">'name'</span>: &#123;<span class="string">'$regex'</span>: <span class="string">'^M.*'</span>&#125;&#125;, name以M开头</span><br><span class="line">$exists 属性是否存在: &#123;<span class="string">'name'</span>: &#123;<span class="string">'$exists'</span>: <span class="keyword">True</span>&#125;&#125;, name属性存在</span><br><span class="line">$type 类型判断: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$type'</span>: <span class="string">'int'</span>&#125;&#125;, age的类型为int</span><br><span class="line">$mod 数字模操作: &#123;<span class="string">'age'</span>: &#123;<span class="string">'$mod'</span>: [<span class="number">5</span>, <span class="number">0</span>]&#125;&#125;, 年龄模<span class="number">5</span>余<span class="number">0</span></span><br><span class="line">$text 文本查询: &#123;<span class="string">'$text'</span>: &#123;<span class="string">'$search'</span>: <span class="string">'shirsen'</span>&#125;&#125;, text类型的属性中包含shirsen字符串</span><br><span class="line">$where 高级条件查询: &#123;<span class="string">'$where'</span>: <span class="string">'obj.fans_count == obj.follows_count'</span>&#125;, 自身粉丝数等于关注数</span><br></pre></td></tr></table></figure></li><li><p><strong>计数</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要统计查询结果有多少条数据，可以调用count()方法，如统计所有数据条数：</span></span><br><span class="line">count = collection.find().count()</span><br><span class="line">print(count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者统计符合某个条件的数据：</span></span><br><span class="line">count = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;).count()</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure></li><li><p><strong>排序</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以调用sort方法，传入排序的字段及升降序标志即可</span></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING)</span><br><span class="line">print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br><span class="line"><span class="comment"># 偏移,可能想只取某几个元素，在这里可以利用skip()方法偏移几个位置，比如偏移2，就忽略前2个元素，得到第三个及以后的元素。</span></span><br><span class="line"></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).skip(<span class="number">2</span>)</span><br><span class="line">print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外还可以用limit()方法指定要取的结果个数</span></span><br><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).skip(<span class="number">2</span>).limit(<span class="number">2</span>)</span><br><span class="line">print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br><span class="line"><span class="comment"># 如果不加limit()原本会返回三个结果，加了限制之后，会截取2个结果返回。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 值得注意的是，在数据库数量非常庞大的时候，如千万、亿级别，最好不要使用大的偏移量来查询数据，很可能会导致内存溢出，</span></span><br><span class="line"><span class="comment"># 可以使用类似find(&#123;'_id': &#123;'$gt': ObjectId('593278c815c2602678bb2b8d')&#125;&#125;) 这样的方法来查询，记录好上次查询的_id。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>更新</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于数据更新可以使用update()方法，指定更新的条件和更新后的数据即可，例如：</span></span><br><span class="line">  </span><br><span class="line">condition = &#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;</span><br><span class="line">people = collection.find_one(condition)</span><br><span class="line">people[<span class="string">'age'</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update(condition, people)</span><br><span class="line">print(result)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在这里我们将name为Kevin的数据的年龄进行更新，首先指定查询条件，然后将数据查询出来，修改年龄，</span></span><br><span class="line"><span class="comment"># 之后调用update方法将原条件和修改后的数据传入，即可完成数据的更新。</span></span><br><span class="line"><span class="comment"># 返回结果是字典形式，ok即代表执行成功，nModified代表影响的数据条数。</span></span><br><span class="line"><span class="comment"># 另外update()方法其实也是官方不推荐使用的方法</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># 在这里也分了update_one()方法和update_many()方法，用法更加严,第二个参数需要使用$类型操作符作为字典的键名，我们用示例感受一下。</span></span><br><span class="line"></span><br><span class="line">condition = &#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;</span><br><span class="line">people = collection.find_one(condition)</span><br><span class="line">people[<span class="string">'age'</span>] = <span class="number">26</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">'$set'</span>: people&#125;)</span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)</span><br><span class="line"><span class="comment"># 在这里调用了update_one方法，第二个参数不能再直接传入修改后的字典，而是需要使用&#123;'$set': people&#125;这样的形式，</span></span><br><span class="line"><span class="comment"># 其返回结果是UpdateResult类型，然后调用matched_count和modified_count属性分别可以获得匹配的数据条数和影响的数据条数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再看一个例子：</span></span><br><span class="line">condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_one(</span><br><span class="line">condition,</span><br><span class="line">&#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line">)</span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)</span><br><span class="line"><span class="comment"># 在这里我们指定查询条件为年龄大于20，然后更新条件为&#123;'$inc': &#123;'age': 1&#125;&#125;，执行之后会讲第一条符合条件的数据年龄加1。</span></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果调用update_many()方法，则会将所有符合条件的数据都更新</span></span><br><span class="line"></span><br><span class="line">condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_many(</span><br><span class="line">    condition,</span><br><span class="line">    &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line">)</span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)</span><br><span class="line"><span class="comment"># 这时所有匹配到的数据都会被更新。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>删除</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除操作比较简单，直接调用remove()方法指定删除的条件即可，符合条件的所有数据均会被删除</span></span><br><span class="line"></span><br><span class="line">result = collection.remove(&#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 另外依然存在两个新的推荐方法，delete_one()和delete_many()方法</span></span><br><span class="line"></span><br><span class="line">result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;)</span><br><span class="line">print(result)</span><br><span class="line">print(result.deleted_count)</span><br><span class="line">result = collection.delete_many(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">25</span>&#125;&#125;)</span><br><span class="line">print(result.deleted_count)</span><br><span class="line"><span class="comment"># delete_one()即删除第一条符合条件的数据，delete_many()即删除所有符合条件的数据，返回结果是DeleteResult类型，</span></span><br><span class="line"><span class="comment"># 可以调用deleted_count属性获取删除的数据条数。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>更多</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 另外PyMongo还提供了一些组合方法，如find_one_and_delete()、find_one_and_replace()、find_one_and_update()，查找后删除、替换、更新操作，用法与上述方法基本一致。</span><br><span class="line"></span><br><span class="line"># 另外还可以对索引进行操作，如create_index()、create_indexes()、drop_index()等。</span><br></pre></td></tr></table></figure></li></ul><h4 id="特殊查询"><a href="#特殊查询" class="headerlink" title="特殊查询"></a>特殊查询</h4><ul><li><p><strong>忽略大小写</strong></p><ul><li><p>可以使用正则查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">name = <span class="string">r"^&#123;&#125;s$"</span>.format(filename)</span><br><span class="line">name = re.complie(name, re.I)</span><br><span class="line">client = pymongo.MongoClient(host, port)</span><br><span class="line">db = client[<span class="string">'database'</span>]</span><br><span class="line">col = db[<span class="string">'collection'</span>]</span><br><span class="line">result = col.find(&#123;<span class="string">'filename'</span>: name&#125;, project=&#123;<span class="string">'_id'</span>: <span class="keyword">False</span>&#125;)</span><br><span class="line"><span class="comment"># 或者使用 $regex 表达式</span></span><br><span class="line">result = col.find(&#123;<span class="string">'filename'</span>: &#123;<span class="string">'$regex'</span>: <span class="string">r"^&#123;&#125;s$"</span>.format(filename), <span class="string">'$options'</span>: <span class="string">'i'</span>&#125;&#125;, project=&#123;<span class="string">'_id'</span>: <span class="keyword">False</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>$options</strong> 支持如下：</p></li></ul></li></ul><style>    table th:nth-of-type(1){        width: 15%;    }    table th:nth-of-type(2){        width: 55%;    }    table th:nth-of-type(3){        width: 30%;    }</style><table><thead><tr><th style="text-align:left">选型</th><th style="text-align:left">含义</th><th style="text-align:left">要求</th></tr></thead><tbody><tr><td style="text-align:left">i</td><td style="text-align:left">大小写不敏感</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">查询中使用了锚，如<code>^</code>或者<code>$</code>，以及匹配<code>\n</code>后的字符串</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">忽视所有空白字符</td><td style="text-align:left">要求<code>$regex</code>与<code>$option</code>合用</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">允许点字符 <code>.</code> 匹配所有的字符，包括换行符</td><td style="text-align:left">要求<code>$regex</code>与<code>$option</code>合用</td></tr></tbody></table><ul><li><p><strong>是否含有</strong></p><ul><li><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找存在name属性的数据</span></span><br><span class="line">col.find_one(&#123;<span class="string">'name'</span>: &#123;<span class="string">'$exists'</span>: <span class="keyword">True</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找name为None的数据</span></span><br><span class="line">col.find(&#123;<span class="string">'name'</span>: &#123;<span class="string">'$exists'</span>: <span class="keyword">True</span>, <span class="string">'$in'</span>: [<span class="keyword">None</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多层结构查询</strong></p><ul><li><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># info 里面嵌套 name</span></span><br><span class="line">col.find_one(&#123;<span class="string">'info.name'</span>: <span class="string">'roux'</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>逻辑查询</strong></p><ul><li><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># and 查询</span></span><br><span class="line">col.find_one(&#123;<span class="string">'name'</span>: <span class="string">'roux'</span>, <span class="string">'id'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># or 查询</span></span><br><span class="line">col.find(&#123;<span class="string">"$or"</span>: [&#123;<span class="string">'name'</span>: <span class="string">'roux'</span>&#125;, &#123;<span class="string">'id'</span>: <span class="number">1</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in 查询</span></span><br><span class="line">col.find(&#123;<span class="string">'name'</span>: &#123;<span class="string">"$in"</span>: [<span class="string">'roux'</span>, <span class="string">'shirsen'</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h4><ul><li><p><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html" target="_blank" rel="noopener">详细用法</a></p></li><li><p><a href="http://api.mongodb.com/python/current/api/pymongo/" target="_blank" rel="noopener">官方文档</a></p></li><li><p><a href="https://www.jianshu.com/p/b5427af1f2a4" target="_blank" rel="noopener">特殊查询</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;最近做毕设用到pymongo，对平常的使用记录一下。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="http://roux.top/categories/Database/"/>
    
    
      <category term="MongoDB" scheme="http://roux.top/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Git设置代理</title>
    <link href="http://roux.top/2019/05/15/Git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>http://roux.top/2019/05/15/Git设置代理/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-05-17T15:55:23.213Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>最近经常出现<code>github</code>仓库<code>clone</code>到本地发生<code>timeout</code>的情况，就想着设置代理来访问下载，果真下载速度从Kb变为Mb了</li></ul><a id="more"></a><h4 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h4><ul><li><p>设置代理前，你需要能够<code>科学上网</code>。否则的话直接查看<code>文末</code>修改<code>hosts文件</code>来加速的方法。</p></li><li><p>全局代理</p><ul><li><code>git config --global http.proxy [ip:port]</code></li><li><code>[ip:port]</code>这个是你自己的代理ip和端口</li></ul></li><li><p>局部代理，在已经<code>clone</code> 好的仓库内执行</p><ul><li><code>git config --local http.proxy [ip:port]</code></li><li><code>[ip:port]</code>这个是你自己的代理ip和端口</li></ul></li><li><p>查询是否使用代理：</p><ul><li><p>查询全局代理</p><ul><li><code>git config --global http.proxy</code></li></ul></li><li><p>查询局部代理</p><ul><li><code>git config --local http.proxy</code></li></ul></li></ul></li><li><p>取消代理：</p><ul><li><code>git config --global --unset http.proxy</code></li><li><code>git config --local --unset http.proxy</code></li></ul></li></ul><h4 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h4><ul><li><a href="https://blog.csdn.net/tsq292978891/article/details/78260066" target="_blank" rel="noopener">参考链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;最近经常出现&lt;code&gt;github&lt;/code&gt;仓库&lt;code&gt;clone&lt;/code&gt;到本地发生&lt;code&gt;timeout&lt;/code&gt;的情况，就想着设置代理来访问下载，果真下载速度从Kb变为Mb了&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="Git" scheme="http://roux.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>活着</title>
    <link href="http://roux.top/2019/05/01/%E6%B4%BB%E7%9D%80/"/>
    <id>http://roux.top/2019/05/01/活着/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-11T03:26:40.269Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>生下来，活下去。</li></ul><a id="more"></a><h4 id="活着"><a href="#活着" class="headerlink" title="活着"></a>活着</h4><p>&emsp;&emsp;印象中小时候看过一部电视剧主人公也叫富贵，一切都在失去，直到一无所有。那个时候的什么也不懂，也没有兴趣和能力去懂，也只能在记忆里留下一丝片段。年龄增长，我生活的环境却没有多大的变化，不过是几次搬家与换学校，身边亲人健在，朋友如旧。记忆中的那些片段更加模糊了。可是忽然有一天，不知怎么的，自己就突然长大了，心理的逐渐成熟让我不知所措，忧虑、迷茫、孤独是我无法避免却又时刻在回避的。高考的失利，亲人的离世，父母逐渐斑白鬓角与佝偻的背脊，让我落泪。我仿佛明白了那么一丝活着的意义。<br>&emsp;&emsp;春去秋来，生活还在继续。大学真的是一个神奇的地方，我们每个人都会在这里开始属于自己的蜕变，也许就是命中注定，说不清，道不明。岁月如水，还没好好开始享受，就开始了实习生涯，曾经的自我以为，在那段日子里破碎一地，快乐、委屈、辛酸…… 还记得那段日子结束后，我做的第一个决定就是好好享受大学生活。我们没有那么多可以失去，也没有那么多值得珍惜。也许这就是这个阶段的活着。<br>&emsp;&emsp;以后谁也说不清，只能努力让自己更加充实与“皮实”。我希望：我既为活着本身而活着，也能为活着之外的一些人和事而活。</p><h4 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h4><ul><li><a href="https://book.douban.com/subject/4913064/" target="_blank" rel="noopener">活着</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;生下来，活下去。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="文学" scheme="http://roux.top/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="观后感" scheme="http://roux.top/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>爱你就像爱生命</title>
    <link href="http://roux.top/2019/04/30/%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD/"/>
    <id>http://roux.top/2019/04/30/爱你就像爱生命/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-06-01T10:18:37.932Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>手里有本好书在读的日子就像是节日一样。</li></ul><a id="more"></a><h4 id="爱情本来的样子"><a href="#爱情本来的样子" class="headerlink" title="爱情本来的样子"></a>爱情本来的样子</h4><p>&emsp;&emsp;我在翻开这本书前，脑海中有不少的假设，最后无一成立。一页页读过去，并没有我认为的浪漫和甜言蜜语，也没有什么山盟海誓，更没有现在那种爱情就是高级消费品的感觉。但在他们温润的语句中，有的是那些点点滴滴，有的是孩子一般的欢喜和担忧，有的是爱情本来的样子。<br>&emsp;&emsp;其实在书中并没有多少惊天动地的浪漫言语，留下的却缓缓流入人的心房，暖了每个季节。<code>我的灵魂里有很多地方玩世不恭，对人傲慢无礼，但是它有一个核心，这个核心害怕黑暗，柔弱的像绵羊一样。</code> 转念一想，我们每个人何尝不是这样的呢。<code>但愿我和你，是一支唱不完的歌</code> <code>我老把和你在一起的时间当节日来度过，我看你也是</code> 可能现这些话已经带不起多少波澜，孩子的真挚的确在成年人看来有些无力，面对现实深深的无力。但不得不承认的是：<code>我老觉得爱情奇怪，它是一种宿命的东西。对我来说，它的内容就是“碰上了，然后就爱上，然后一点办法也没有了”。它就是这样！</code> 这也许就是爱情本来的样子。<br>&emsp;&emsp;关于李银河对王小波的评价：<code>一位浪漫骑士，一位行吟诗人，一位自由思想者</code> 一点不过。王小波与李银河的书信中没有具体的诗和浪漫，因为都在字里行间流淌着，自由的思想也能在《绿毛水怪》里窥见。<br>&emsp;&emsp;这本书里我读出的更多是爱情本身的样子，没有过多的掺杂。浪漫的就如 <code>我们好像在池塘的水底，从一个月亮走向另一个月亮。</code>可在如今，功利和名誉，空荡的精神世界，我们忘记了爱情的模样，就如 <code>奥克塔维奥-帕斯</code> 所说：<code>在20世纪各项伟大的起义中，爱情缺席了......</code> 21世纪的爱情也变了味道，逐渐缺失了曾经的优雅与浪漫，变得形式主义、功利，成为了一种有点昂贵与费神的高级消费品。<br>&emsp;&emsp;到底是谁变了？</p><h4 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h4><ul><li><a href="https://book.douban.com/subject/27071421/" target="_blank" rel="noopener">爱你就像爱生命</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;手里有本好书在读的日子就像是节日一样。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="文学" scheme="http://roux.top/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="观后感" scheme="http://roux.top/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Windows10更新系统导致控制台和部分软件中文乱码</title>
    <link href="http://roux.top/2019/04/29/Windows10%E8%BD%AF%E4%BB%B6%E4%B9%B1%E7%A0%81/"/>
    <id>http://roux.top/2019/04/29/Windows10软件乱码/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T04:23:26.140Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>昨天更新windows10家庭版的1803版本到最新的版本，更新完成后发现控制台和部分软件出现了乱码的现象，网上找了不少的解决办法，最终自己完全解决了！</li></ul><a id="more"></a><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li><p>首先，定位到 <code>C:\Users\用户\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Windows PowerShell</code>，鼠标右击windows powershell以管理员运行，复制粘贴以下命令运行，<code>Get-AppxPackage -AllUsers| Foreach {Add-AppxPackage -DisableDevelopmentMode -Register “$($_.InstallLocation)\AppXManifest.xml”}</code> 或者 <code>Get-AppxPackage | % { Add-AppxPackage -DisableDevelopmentMode -Register &quot;$($_.InstallLocation)\AppxManifest.xml&quot; -verbose }</code></p></li><li><p>上个阶段会出现很多的错误，第一个命令执行完了可以执行第二个的。完成后会解决部分的软件乱码，但是还有很多无法解决。</p></li><li><p>接下来，定位到 <code>设置-&gt;时间和语言-&gt;区域和语言-&gt;管理语言设置-&gt;管理-&gt;更改系统区域设置</code>在这里我选择了<code>中文简体-新加坡</code>，然后重启。</p></li><li><p>重启后会发现乱码消失了，然后将新加坡换回中国就好了(也可以不换)。</p></li><li><p>如果还有问题，比如说我有一个脚本是爬取菜鸟教程的设计模式的文章，爬取文章title的时候出现控制台乱码，但是爬取其他比如百度的就正常，这可能是网站的编码压缩原因(那就需要你自己进行解压缩)。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;昨天更新windows10家庭版的1803版本到最新的版本，更新完成后发现控制台和部分软件出现了乱码的现象，网上找了不少的解决办法，最终自己完全解决了！&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="Windwos" scheme="http://roux.top/tags/Windwos/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件</title>
    <link href="http://roux.top/2019/04/27/Chrome%E6%8F%92%E4%BB%B6/"/>
    <id>http://roux.top/2019/04/27/Chrome插件/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-05-10T11:20:37.254Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>关于Chrome上一些好用的插件(需要科学上网)</li></ul><a id="more"></a><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul><li><strong>AdGuard广告拦截器</strong><ul><li>看名字就知道是拦截各大网站广告的插件。这个插件分为免费和付费版，个人用的话免费版是足够。它的拦截率还是很不错的，而且里面有各种拦截的规则，支持自定义和自己拦截元素，更新规则的频率还可以。</li><li><a href="https://chrome.google.com/webstore/detail/adguard-adblocker/bgnkhhnnamicmpeenaelnjfhikgbkllg?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Infinity 新标签页</strong><ul><li>提供新的标签页的插件。这个插件可以自定义新标签页的搜索引擎、壁纸，以及一些好用的工具，避免每次需要打开一些常用的网页的时候还要搜索打开。它带有云端备份和同步的功能，还带有工具商店可以供大家选择。</li><li><a href="https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Stylus</strong><ul><li>Stylus 是一个调整网页外观的用户样式管理器。这个插件可以为许多知名的网站提供精美的主题和皮肤，有相关的主题和皮肤网站供大家下载。</li><li><a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne" target="_blank" rel="noopener">URL链接</a></li><li><a href="https://userstyles.org/" target="_blank" rel="noopener">主题库</a></li></ul></li></ul><hr><ul><li><strong>LastPass: Free Password Manager</strong><ul><li>一款密码管理器。这个插件可以加密保存你的密码(听说加密算法很复杂)，方便你在任何时候浏览网页一键登录，并且可以避免密码保存在本地的风险(我还是比较相信云端的)，而且可以导入你的chrome保存的密码与管理密码。</li><li><a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Tampermonkey BETA</strong><ul><li>一款加载网页脚本的插件。这个插件可以用来加载一些自定义的脚本，用来美化浏览器并实现一些你想要的功能。它提供了一个脚本网站方便用户下载和发布相关的脚本。</li><li><a href="https://chrome.google.com/webstore/detail/tampermonkey-beta/gcalenpjmijncebpfijmoaglllgpjagf" target="_blank" rel="noopener">URL链接</a></li><li><a href="https://greasyfork.org/zh-CN/" target="_blank" rel="noopener">脚本库</a></li></ul></li></ul><hr><ul><li><strong>简 悦</strong><ul><li>一款提供阅读的插件。这个插件将网页进行简化，提供一个合适阅读的排版。用户可以进行相关的偏好设置(选项还挺多，并且有多种模式)，并且提供了相关的论坛供用户交流。</li><li><a href="http://ksria.com/simpread/" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Google 翻译</strong><ul><li>这个插件不用说了。</li><li><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>有道词典Chrome划词插件</strong><ul><li>这个插件主要就是方便大家看英文页面。支持查词、长句翻译。个人感觉翻译的质量还可以。</li><li><a href="https://chrome.google.com/webstore/detail/%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8chrome%E5%88%92%E8%AF%8D%E6%8F%92%E4%BB%B6/eopjamdnofihpioajgfdikhhbobonhbb" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>沙拉查词-聚合词典划词翻译</strong><ul><li>这个插件和有道功能相似。但是这个聚合了好几个翻译方案，并且使用起来也很方便。可以搭配有道进行使用。</li><li><a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg/related" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>分享到微信</strong><ul><li>这个插件主要的目的就是让大家可以把网页分享到微信</li><li><a href="https://chrome.google.com/webstore/detail/%E5%88%86%E4%BA%AB%E5%88%B0%E5%BE%AE%E4%BF%A1/gjmlaljbhjlbmdgdglcnilnfjeignbij" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>高效网页截图编辑插件</strong><ul><li>一款网页截图插件。可以像画图软件那样用直线、箭头、圆圈、文字做出标识。并可以方便的通过链接或者附件分享。目前使用的是Snipaste所以这款插件没有使用了。</li><li><a href="https://chrome.google.com/webstore/detail/explain-and-send-screensh/mdddabjhelpilpnpgondfmehhcplpiin" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Fatkun图片批量下载</strong><ul><li>一款下载图片的插件。很不错的插件，不过我用的场合不多。</li><li><a href="https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>OneTab</strong><ul><li>一款节约Chrome内存减轻标签页混乱的插件。如果发现自己有太多的标签页时，单击OneTab图标，将所有标签页转换成一个列表。当需要再次访问这些标签页时，可以单独或全部恢复就好了。</li><li><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Octotree</strong><ul><li>一款显示github的仓库代码树的插件。每次查看github仓库的代码的时候非常麻烦，这款插件简化了许多的操作。</li><li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnag" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Vimium</strong><ul><li>一款让你的浏览器像操作Vim一样的插件。如果你是Vim爱好者，或者你喜欢简单的操作方式，你都可以尝试这款插件。</li><li><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>IDM Integration Module</strong><ul><li>一款下载插件，需要配合IDM客户端来使用(收费，但是不贵)。这个插件可以监听各大浏览器，代替浏览器自己的下载器，而且它支持多种格式和多线程下载，配合一些脚本，基本可以下载所有的东西。</li><li><a href="https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Proxy SwitchyOmega</strong><ul><li>一款Chrome的代理切换插件。目前我主要在Ubuntu下科学上网使用，Windows下使用酸酸乳就好了。</li><li><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>WEB前端助手(FeHelper)</strong><ul><li>前端开发和爬虫使用。内置了很多的小工具，再也不用费事了。</li><li><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>XPath Helper</strong><ul><li>爬虫使用。写xpath表达式进行预览。</li><li><a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>User-Agent Switcher</strong><ul><li>爬虫使用。用来切换UA，查看网页的情况。</li><li><a href="https://chrome.google.com/webstore/detail/user-agent-switcher/clddifkhlkcojbojppdojfeeikdkgiae" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>类似的网站 - 发现相关网站</strong><ul><li>主要功能就是发现类似的网站。尤其是在我们找资源的时候，这个网站没有，但是往往在另外一个存在。</li><li><a href="https://chrome.google.com/webstore/detail/similar-sites-discover-re/necpbmbhhdiplmfhmjicabdeighkndkn" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul><hr><ul><li><strong>Video Speed Controller</strong><ul><li>一款控制HTML5视频播放速度的插件。对于我这种经常需要看视频的人，往往一些视频需要加速，但是好多网站不提供倍速或者最多2倍速，很浪费时间。这款插件可以最高提供16倍速，配合一些HTML5播放的脚本，不用太爽。</li><li><a href="https://chrome.google.com/webstore/detail/video-speed-controller/nffaoalbilbmmfgbnbgppjihopabppdk" target="_blank" rel="noopener">URL链接</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;关于Chrome上一些好用的插件(需要科学上网)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="Chrome" scheme="http://roux.top/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>随笔2019-04-26</title>
    <link href="http://roux.top/2019/04/26/%E9%9A%8F%E7%AC%942019-04-26/"/>
    <id>http://roux.top/2019/04/26/随笔2019-04-26/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-04-26T15:09:33.211Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>关于互联网的一些瞎扯。</li></ul><a id="more"></a><h4 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h4><p>&emsp;&emsp;去年秋招结束后，各大公司就相继出现裁员的情况，更甚的是许多大公司也有出现毁约应届生的情况。看到这些新闻，我知道一些变化发生了。首先，互联网的红利已经没有了，可以看到今年春招的要求变得更高了，公司内部也开始裁员并消化以前抢占市场所招来的人才，也不会出现以前随便培训一下就能找到ok的工作的情况。其次，随着中国互联网的发展，门槛是越来越低，市场的一般需求也趋于饱和，大家都开始提高招聘标准。<br>&emsp;&emsp;这些情况的出现，也反映在教育和资源方面：转行到计算机的人每年都在增长，去年和今年达到高峰，明年可能会更高、读研的人也越来越多，并且大多数都是想考一个和计算机相关的专业导致今年各大优秀院校的计算机院和软院全部爆满、网上的资源也唾手可得，网课及相关资料一大堆。<br>&emsp;&emsp;我想，后面可能会出现更激烈的优胜劣汰，并且一时半会不会发生大的改变。这个时候应对的方法就是努力的提升自我，掌握核心技术。<br>&emsp;&emsp;看大佬们的文章看的多了，感觉自己也会瞎扯了，哈哈！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;关于互联网的一些瞎扯。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="生活" scheme="http://roux.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://roux.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>windows10命令</title>
    <link href="http://roux.top/2019/04/20/windows10%E5%91%BD%E4%BB%A4/"/>
    <id>http://roux.top/2019/04/20/windows10命令/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-26T12:58:51.386Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>记录<code>window10</code>CMD下面的一些命令</li></ul><a id="more"></a><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">1. calc：启动计算器</span><br><span class="line"></span><br><span class="line">2. appwiz.cpl：程序和功能</span><br><span class="line"></span><br><span class="line">3. certmgr.msc：证书管理实用程序</span><br><span class="line"></span><br><span class="line">   4. charmap：启动字符映射表</span><br><span class="line"></span><br><span class="line">   5. chkdsk.exe：Chkdsk磁盘检查(管理员身份运行命令提示符)</span><br><span class="line"></span><br><span class="line">   6. cleanmgr: 打开磁盘清理工具</span><br><span class="line"></span><br><span class="line">   7. cliconfg：SQL SERVER 客户端网络实用工具</span><br><span class="line"></span><br><span class="line">   8. cmstp：连接管理器配置文件安装程序</span><br><span class="line"></span><br><span class="line">   9. cmd.exe：CMD命令提示符</span><br><span class="line"></span><br><span class="line">   10. 自动关机命令</span><br><span class="line"></span><br><span class="line">       Shutdown -s -t 600：表示600秒后自动关机</span><br><span class="line">       </span><br><span class="line">       Shutdown -r -t 600：表示600秒后自动重启</span><br><span class="line"></span><br><span class="line">       shutdown -a ：可取消定时关机</span><br><span class="line"></span><br><span class="line">       rundll32 user32.dll,LockWorkStation：表示锁定计算机</span><br><span class="line"></span><br><span class="line">   11. colorcpl：颜色管理，配置显示器和打印机等中的色彩</span><br><span class="line"></span><br><span class="line">   12. CompMgmtLauncher：计算机管理</span><br><span class="line"></span><br><span class="line">   13. compmgmt.msc：计算机管理</span><br><span class="line"></span><br><span class="line">   14. credwiz：备份或还原储存的用户名和密码</span><br><span class="line"></span><br><span class="line">   15. comexp.msc：打开系统组件服务</span><br><span class="line"></span><br><span class="line">   16. control：控制面版</span><br><span class="line"></span><br><span class="line">   17. dcomcnfg：打开系统组件服务</span><br><span class="line"></span><br><span class="line">   18. Dccw：显示颜色校准</span><br><span class="line"></span><br><span class="line">   19. devmgmt.msc：设备管理器</span><br><span class="line"></span><br><span class="line">   20. desk.cpl：屏幕分辨率</span><br><span class="line"></span><br><span class="line">   21. dfrgui：优化驱动器 Windows 7→dfrg.msc：磁盘碎片整理程序</span><br><span class="line"></span><br><span class="line">   22. dialer：电话拨号程序</span><br><span class="line"></span><br><span class="line">   23. diskmgmt.msc：磁盘管理</span><br><span class="line"></span><br><span class="line">   24. dvdplay：DVD播放器</span><br><span class="line"></span><br><span class="line">   25. dxdiag：检查DirectX信息</span><br><span class="line"></span><br><span class="line">   26. eudcedit：造字程序</span><br><span class="line"></span><br><span class="line">   27. eventvwr：事件查看器</span><br><span class="line"></span><br><span class="line">   28. explorer：打开资源管理器</span><br><span class="line"></span><br><span class="line">   29. Firewall.cpl：Windows防火墙</span><br><span class="line"></span><br><span class="line">   30. FXSCOVER：传真封面编辑器</span><br><span class="line"></span><br><span class="line">   31. fsmgmt.msc：共享文件夹管理器</span><br><span class="line"></span><br><span class="line">   32. gpedit.msc：组策略</span><br><span class="line"></span><br><span class="line">   33. hdwwiz.cpl：设备管理器</span><br><span class="line"></span><br><span class="line">   34. inetcpl.cpl：Internet属性</span><br><span class="line"></span><br><span class="line">   35. intl.cpl：区域</span><br><span class="line"></span><br><span class="line">   36. iexpress：木马捆绑工具，系统自带</span><br><span class="line"></span><br><span class="line">   37. joy.cpl：游戏控制器</span><br><span class="line"></span><br><span class="line">   38. logoff：注销命令</span><br><span class="line"></span><br><span class="line">   39. lusrmgr.msc：本地用户和组</span><br><span class="line"></span><br><span class="line">   40. lpksetup：语言包安装/删除向导，安装向导会提示下载语言包</span><br><span class="line"></span><br><span class="line">   41. lusrmgr.msc：本机用户和组</span><br><span class="line"></span><br><span class="line">   42. main.cpl：鼠标属性</span><br><span class="line"></span><br><span class="line">   43. mmsys.cpl：声音</span><br><span class="line"></span><br><span class="line">   44. magnify：放大镜实用程序</span><br><span class="line"></span><br><span class="line">   45. mem.exe：显示内存使用情况(如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe&gt;d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。)</span><br><span class="line"></span><br><span class="line">   46. MdSched:Windows内存诊断程序</span><br><span class="line"></span><br><span class="line">   47. mmc：打开控制台</span><br><span class="line"></span><br><span class="line">   48. mobsync：同步命令</span><br><span class="line"></span><br><span class="line">   49. mplayer2：简易widnows media player</span><br><span class="line"></span><br><span class="line">   50. Msconfig.exe：系统配置实用程序</span><br><span class="line"></span><br><span class="line">   51. msdt：微软支持诊断工具</span><br><span class="line"></span><br><span class="line">   52. msinfo32：系统信息</span><br><span class="line"></span><br><span class="line">   53. mspaint：画图</span><br><span class="line"></span><br><span class="line">   54. Msra：Windows远程协助</span><br><span class="line"></span><br><span class="line">   55. mstsc：远程桌面连接</span><br><span class="line"></span><br><span class="line">   56. NAPCLCFG.MSC：客户端配置</span><br><span class="line"></span><br><span class="line">   57. ncpa.cpl：网络连接</span><br><span class="line"></span><br><span class="line">   58. narrator：屏幕“讲述人”</span><br><span class="line"></span><br><span class="line">   59. Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项</span><br><span class="line"></span><br><span class="line">   60. netstat : an(TC)命令检查接口</span><br><span class="line"></span><br><span class="line">   61. notepad：打开记事本</span><br><span class="line"></span><br><span class="line">   62. Nslookup：IP地址侦测器</span><br><span class="line"></span><br><span class="line">   63. odbcad32：ODBC数据源管理器</span><br><span class="line"></span><br><span class="line">   64. OptionalFeatures：打开“打开或关闭Windows功能”对话框</span><br><span class="line"></span><br><span class="line">   65. osk：打开屏幕键盘</span><br><span class="line"></span><br><span class="line">   66. perfmon.msc：计算机性能监测器</span><br><span class="line"></span><br><span class="line">   67. perfmon：计算机性能监测器</span><br><span class="line"></span><br><span class="line">   68. PowerShell：提供强大远程处理能力</span><br><span class="line"></span><br><span class="line">   69. printmanagement.msc：打印管理</span><br><span class="line"></span><br><span class="line">   70. powercfg.cpl：电源选项</span><br><span class="line"></span><br><span class="line">   71. psr：问题步骤记录器</span><br><span class="line"></span><br><span class="line">   72. Rasphone：网络连接</span><br><span class="line"></span><br><span class="line">   73. Recdisc：创建系统修复光盘</span><br><span class="line"></span><br><span class="line">   74. Resmon：资源监视器</span><br><span class="line"></span><br><span class="line">   75. Rstrui：系统还原</span><br><span class="line"></span><br><span class="line">   76. regedit.exe：注册表</span><br><span class="line"></span><br><span class="line">   77. regedt32：注册表编辑器</span><br><span class="line"></span><br><span class="line">   78. rsop.msc：组策略结果集</span><br><span class="line"></span><br><span class="line">   79. sdclt：备份状态与配置，就是查看系统是否已备份</span><br><span class="line"></span><br><span class="line">   80. secpol.msc：本地安全策略</span><br><span class="line"></span><br><span class="line">   81. services.msc：本地服务设置</span><br><span class="line"></span><br><span class="line">   82. sfc /scannow：扫描错误并复原/windows文件保护</span><br><span class="line"></span><br><span class="line">   83. sfc.exe：系统文件检查器</span><br><span class="line"></span><br><span class="line">   84. shrpubw：创建共享文件夹</span><br><span class="line"></span><br><span class="line">   85. sigverif：文件签名验证程序</span><br><span class="line"></span><br><span class="line">   86. slui：Windows激活，查看系统激活信息</span><br><span class="line"></span><br><span class="line">   87. slmgr.vbs -dlv ：显示详细的许可证信息</span><br><span class="line"></span><br><span class="line">   88. snippingtool：截图工具，支持无规则截图</span><br><span class="line"></span><br><span class="line">   89. soundrecorder：录音机，没有录音时间的限制</span><br><span class="line"></span><br><span class="line">   90. StikyNot：便笺</span><br><span class="line"></span><br><span class="line">   91. sysdm.cpl：系统属性</span><br><span class="line"></span><br><span class="line">   92. sysedit：系统配置编辑器</span><br><span class="line"></span><br><span class="line">   93. syskey：系统加密，一旦加密就不能解开，保护系统的双重密码</span><br><span class="line"></span><br><span class="line">   94. taskmgr：任务管理器(旧版)</span><br><span class="line"></span><br><span class="line">   95. TM任务管理器(新版)</span><br><span class="line"></span><br><span class="line">   96. taskschd.msc：任务计划程序</span><br><span class="line"></span><br><span class="line">   97. timedate.cpl：日期和时间</span><br><span class="line"></span><br><span class="line">   98. UserAccountControlSettings用户账户控制设置</span><br><span class="line"></span><br><span class="line">   99. utilman：辅助工具管理器</span><br><span class="line"></span><br><span class="line">   100 .wf.msc：高级安全Windows防火墙</span><br><span class="line"></span><br><span class="line">   101. WFS：Windows传真和扫描</span><br><span class="line"></span><br><span class="line">   102. wiaacmgr：扫描仪和照相机向导</span><br><span class="line"></span><br><span class="line">   103. winver：关于Windows</span><br><span class="line"></span><br><span class="line">   104. wmimgmt.msc：打开windows管理体系结构(WMI)</span><br><span class="line"></span><br><span class="line">   105. write：写字板</span><br><span class="line"></span><br><span class="line">   106. wscui.cpl：操作中心</span><br><span class="line"></span><br><span class="line">   107. wuapp：Windows更新</span><br><span class="line"></span><br><span class="line">   108. wscript：windows脚本宿主设置</span><br></pre></td></tr></table></figure><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li><a href="http://www.windowszj.com/news/win10/28486.html" target="_blank" rel="noopener">windows系统之家</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;记录&lt;code&gt;window10&lt;/code&gt;CMD下面的一些命令&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="Others" scheme="http://roux.top/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>C++陷阱与用法</title>
    <link href="http://roux.top/2018/12/14/C++%E9%99%B7%E9%98%B1%E4%B8%8E%E7%94%A8%E6%B3%95/"/>
    <id>http://roux.top/2018/12/14/C++陷阱与用法/</id>
    <published>2018-12-13T16:00:00.000Z</published>
    <updated>2018-12-18T10:58:08.716Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>C++是一门很容易采坑的语言，所以对其一些常见的陷阱和误解进行收集与总结，同时对一些新的特性进行了解。</li><li>此文包含了自己遇到的问题以及在公司看到一位师兄写的文章的一些内容，外加一些网上看到的(代码已验证)</li></ul><a id="more"></a><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><ol><li><p><strong>编译器为什么不给局部变量和成员变量做默认初始化</strong></p><ul><li><strong>因为效率</strong>，C++被设计为系统级的编程语言，效率是优先考虑的方向，c++秉持的一个设计哲学是不为不必要的操作付出任何额外的代价</li><li>从安全的角度出发，定义变量的时候赋初值是一个好的习惯，<strong>很多错误皆因未正确初始化而起</strong>，C++11支持成员变量定义的时候直接初始化，成员变量尽量在成员初始化列表里初始化，且要按定义的顺序初始化</li></ul></li><li><p><strong>全局变量</strong></p><ul><li><strong>C++在不同模块（源文件）里定义的全局变量，不保证构造顺序</strong>；但保证在同一模块（源文件）里定义的全局变量，按定义的先后顺序构造，按定义的相反次序析构</li><li><strong>如果全局变量有依赖关系，那么就把它们放在同一个源文件定义，且按正确的顺序定义，确保依赖关系正确</strong>，而不是定义在不同源文件；对于系统中的单件，单件依赖也要注意这个问题</li></ul></li><li><p><strong>new与delete</strong></p><ul><li>delete之后加上语句<code>delete p; p = nullptr;</code>（避免重复释放）</li><li>保证<code>delete[]</code>匹配<code>new[]</code>和<code>delete</code>匹配<code>new</code></li><li>例外：<code>typedef T type[N];</code> <code>T * pT = new type; delete[] pT;</code></li></ul></li><li><p><strong>模板特化</strong></p><ul><li>C++ 本身要求，那几个自动生成的特殊的构造函数以及运算符必须是非模版</li><li>模版产生的函数一定与普通函数不等价。也就是意味着，模版无法生成那些函数与运算符，也不能重写虚函数</li><li>C++ 不允许在类域内显式特化类成员函数</li></ul></li><li><p><strong>enum hack</strong></p><ul><li><code>enum hack</code>的行为更像<code>#define</code>而不是<code>const</code>，如果你不希望别人得到你的常量成员的指针或引用，你可以用<code>enum hack</code>替代之。（为什么不直接用<code>#define</code>呢？首先，因为<code>#define</code>是字符串替换，所以不利于程序调试。其次，<code>#define</code>的可视范围难以控制，比如你怎么让<code>#define</code>定义的常量只在一个类内可见呢？除非你用<code>#undef</code></li><li>使用<code>enum hack</code>不会导致 “不必要的内存分配”</li><li><p>使用技巧：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// static const int GameTurn;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;GameTurn = <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> scores[GameTurn];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// const int Game::GameTurn = 10;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>#define宏</strong></p><ul><li>多用圆括号<code>#define ADD(a, b) ((a)+(b))</code></li><li><p>看情况使用花括号(用大括号将宏定义的多条表达式括起来)(<code>if语句`</code>do{}while(0)语句`等)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a,b) \</span></span><br><span class="line">&#123; \</span><br><span class="line">    a ^=b; \</span><br><span class="line">    b ^=a; \</span><br><span class="line">    a ^=b; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>结构体的string赋值</strong></p><ul><li><p>代码1：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">      <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">World</span> &#123;</span></span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">World</span> *<span class="title">next</span>;</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          World *wr = (World*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(World));</span><br><span class="line">          wr-&gt;name = <span class="string">"hello"</span>;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; wr-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>最终的输出不是简单的一个<code>hello</code>，可以发现返回的code不是0并且会运行很长时间(Segmentation fault)。原因是这里用的是C中的<code>malloc</code>而不是<code>new</code></li><li><code>new</code>在分配内存时会调用默认的构造函数，而<code>malloc</code>不会调用(string没有调用构造函数导致错误)</li></ul></li><li><p>代码2：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line">      <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"hello"</span>;  </span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str();  <span class="comment">// 指针常量  </span></span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">          s[<span class="number">1</span>] = <span class="string">'m'</span>;  </span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>两个输出分别为<code>hello</code>和<code>hmllo</code>。原因是<code>string的c_str()</code>返回的指针是由string管理的，因此它的生命期是string对象的生命期，而string类的实现实际上封装着一个<code>char*</code>的指针，而<code>c_str()</code>直接返回该指针的引用，因此string对象的改变会直接影响已经执行过的c_str()返回的指针引用</li></ul></li></ul></li><li><p><strong>eof与fail</strong></p><ul><li><strong>只要遇到结束符，流就会将状态置为EOF，而不管置位前的操作是否成功</strong>。因此，不能在调用函数后通过eof来判断函数调用是否读到文件末尾了，而应该直接判断调用本身是否成功</li><li><strong>在文件eof的时候也会同时置fail</strong>，所以，循环读取文件的时候，要将fail和eof结合起来使用：在循环判断中使用fail，fail失败后再使用eof</li></ul></li><li><p><strong>stream与buffer</strong></p><ul><li>前面<code>stream</code>后面<code>buffer</code></li><li>作用：<code>代表一个设备</code> <code>数据临时存储</code></li><li>访问方式：<code>FIFO</code> <code>随机访问</code></li><li><p>数据内容：<code>字符流</code> <code>二进制</code></p></li><li><p>当然，并不是说stream和buffer就毫无关系了，stream为了提高性能，实现的时候就用到了buffer</p></li></ul></li><li><p><strong>操作符短路</strong></p><ul><li><p>考虑以下函数：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  Play::get() &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApple() || getMelon()) &#123;</span><br><span class="line">        eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<code>getApple()</code>返回<code>true</code>,就不会就不会调用<code>getMelon()</code>了。这就是操作符短路</li></ul></li><li><p>修改如下：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  Play::get() &#123;</span><br><span class="line"><span class="keyword">bool</span> apple = getApple();</span><br><span class="line"><span class="keyword">bool</span> melon = getMelon();</span><br><span class="line">    <span class="keyword">if</span> (apple || melon) &#123;</span><br><span class="line">        eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>stl容器的遍历删除要小心迭代器失效，vector,list,map,set等各有不同的写法</strong> </p><ul><li>详情跳转<a href="http://roux.top/2018/12/14/C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88/">此文</a>    </li></ul></li><li><p><strong>理解const</strong></p><ul><li>积极的使用const，理解const不仅仅是一种语法层面的保护机制，也会影响程序的编译和运行（const常量会被编码到机器指令）</li></ul></li><li><p><strong>四种转型</strong></p><ul><li>尽量少用转型，强制类型转换是C Style，如果你的C++代码需要类型强转，你需要去考虑是否设计有问题</li></ul></li><li><p><strong>规范的代码</strong></p><ul><li>打开的句柄要关闭，加锁/解锁，new/delete，new[]/delete[]，malloc/free要配对，可以使用RAII技术防止资源泄露，编写符合规范的代码</li></ul></li><li><p><strong>抽象基类的析构函数要加virtual关键字</strong></p><ul><li>virtual dtor跟普通虚函数一样，基类指针指向子类对象的时候，delete ptr，根据虚函数特征，如果析构函数是普通函数，那么就调用ptr显式（基类）类型的析构函数；如果析构函数是virtual，则会调用子类的析构函数，然后再调用基类析构函数</li></ul></li><li><p><strong>避免在构造函数和析构函数里调用虚函数</strong></p><ul><li>构造函数里，对象并没有完全构建好，此时调用虚函数不一定能正确绑定，析构亦如此</li></ul></li><li><p><strong>协议尽量不要传float，如果传float要了解NaN的概念，要做好检查，避免恶意传播</strong></p></li><li><p><strong>字节对齐</strong></p><ul><li>字节对齐能让存储器访问速度更快。 </li><li>字节对齐跟cpu架构相关，有些cpu访问特定类型的数据必须在一定地址对齐的储存器位置，否则会触发异常。</li><li>字节对齐的另一个影响是调整结构体成员变量的定义顺序，有可能减少结构体大小，这在某些情况下，能节省内存</li></ul></li><li><p><strong>减少依赖，注意隔离</strong></p><ul><li>最大限度的减少文件间的依赖关系，用前向声明拆解相互依赖。了解pimpl技术。</li><li>头文件要自给自足，不要包含不必要的头文件，也不要把该包含的头文件推给user去包含，一句话，头文件包含要不多不少刚刚好</li></ul></li><li><p><strong>整型一般用int，long就好，用short，char需要很仔细，要防止溢出</strong></p><ul><li>大多数情况下，用int，long就很好，long一般等于机器字长，long能直接放到寄存器，硬件处理起来速度也更快</li><li>由于字节对齐，用short，char可能大小并不能真正减少，而且1,2个字节的整型位数太少，很容易溢出</li></ul></li><li><p><strong>std::map还是std::unorder_map</strong> </p><ul><li>想清楚他们的利弊，map是用红黑树做的，unorder_map底层是hash表做的，hash表相对于红黑树有更高的查找性能。hash表的效率取决于hash算法和冲突解决方法（一般是拉链法，hash桶），以及数据分布，如果负载因子高，就会降低命中率，为了提高命中率，就需要扩容，重新hash，而重新hash是很慢的，相当于卡一下。而红黑树有更好的平均复杂度，所以如果数据量不是特别大，map是胜任的</li></ul></li><li><p><strong>循环可终止</strong></p><ul><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">5</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>组合优先于继承，继承是一种最强的类间关系</strong></p></li><li><p><strong>了解延迟计算和分散计算</strong> </p><ul><li>分散计算是把任务分散，打碎，避免一次大计算量，卡住程序</li><li>延迟计算和分散计算都是常见的套路</li></ul></li><li><p><strong>从输入流获取数据，要做好数据不够的处理，要加try catch；没有被吞咽的exception，会被传播</strong></p></li><li><p><strong>内存拷贝小心内存越界；memcpy，memset有很强的限制，仅能用于<a href="http://roux.top/2018/12/13/C++%E4%B9%8BPOD%E7%B1%BB%E5%9E%8B/">POD结构</a>，不能作用于stl容器或者带有虚函数的类</strong></p><ul><li>带虚函数的类对象会有一个虚函数表的指针，memcpy将破坏该指针指向</li></ul></li><li><p><strong>用户stack空间很有限</strong></p><ul><li>一般而言，用户栈只有几兆（典型大小是4M，8M），所以栈上创建的对象不能太大；虽然递归函数能简化程序编写，但也常常带来运行速度变慢的问题，所以需要预估好递归深度，优先考虑非递归实现版本</li></ul></li><li><p><strong>函数调用的性能开销</strong></p><ul><li>函数调用的性能开销（栈帧建立和销毁，参数传递，控制转移），性能敏感函数考虑inline</li><li>X86_64体系结构因为通用寄存器数目增加到16个，所以64位系统下参数数目不多的函数调用，将会由寄存器传递代替压栈方式传递参数，但栈帧建立、撤销和控制转移依然会对性能有所影响</li></ul></li><li><p><strong>安全版本函数</strong></p><ul><li>用c标准库的安全版本（带n标识）替换非安全版本 ，比如用strncpy替代strcpy，用snprintf替代sprintf，用strncat代替strcat，用strncmp代替strcmp，memcpy(dst, src, n)要确保[dst，dst+n]和[src, src+n]都有有效的虚拟内存地址空间。；</li><li>多线程环境下，要用系统调用或者库函数的安全版本代替非安全版本（_r版本），谨记strtok，gmtime等标准c函数都不是线程安全的</li></ul></li><li><p><strong>理解std::vector的底层实现</strong></p><ul><li>vector是动态扩容的，2的次方往上翻，为了确保数据保存在连续空间，每次扩充，会将原member悉数拷贝到新的内存块； 不要保存vector内对象的指针，扩容会导致其失效 ；可以通过保存其下标index替代</li><li>运行过程中需要动态增删的vector，不宜存放大的对象本身 ，因为扩容会导致所有成员拷贝构造，消耗较大，可以通过保存对象指针替代</li><li>理解at()和operator[]的区别 ：at()会做下标越界检查，operator[]提供数组索引级的访问，在release版本下不会检查下标，VC会在Debug版本会检查；c++标准规定:operator[]不提供下标安全性检查</li><li>resize()是重置大小；reserve()是预留空间，并未改变size()，可避免多次扩容； clear()并不会导致空间收缩 ，如果需要释放空间，可以跟空的vector交换，std::vector <t>.swap(v)，c++11里shrink_to_fit()也能收缩内存</t></li></ul></li><li><p><strong>std::sort()的比较函数有很强的约束</strong></p><ul><li>如果要用，要自己提供比较函数或者函数对象，一定搞清楚什么叫<a href="http://roux.top/2018/12/13/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F/">严格弱排序</a></li><li>尽量对索引或者指针sort，而不是针对对象本身，因为如果对象比较大，交换（复制）对象比交换指针或索引更耗费</li></ul></li><li><p><strong>用sprintf格式化字符串的时候，类型和格式化符号要严格匹配，因为sprintf的函数实现里是按格式化串从栈上取参数，任何不一致，都有可能引起不可预知的错误； /usr/include/inttypes.h里定义了跨平台的格式化符号，比如PRId64用于格式化int64_t</strong></p></li><li><p><strong>了解智能指针，理解基于引用计数法的智能指针实现方式，了解所有权转移的概念，理解shared_ptr和unique_ptr的区别和适用场景</strong></p></li></ol><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><ul><li>首先很感谢我认识的师兄，在他们那里学到了很多的知识</li><li>本文后面会不时的更新，有错误的地方点击右下角联系我，谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C++是一门很容易采坑的语言，所以对其一些常见的陷阱和误解进行收集与总结，同时对一些新的特性进行了解。&lt;/li&gt;
&lt;li&gt;此文包含了自己遇到的问题以及在公司看到一位师兄写的文章的一些内容，外加一些网上看到的(代码已验证)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="语言" scheme="http://roux.top/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://roux.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++迭代器失效</title>
    <link href="http://roux.top/2018/12/14/C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88/"/>
    <id>http://roux.top/2018/12/14/C++迭代器失效/</id>
    <published>2018-12-13T16:00:00.000Z</published>
    <updated>2018-12-18T10:58:01.935Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>C++迭代器很好用，但是使用的时候一不留神就会出错，迭代器失效就是其中之一。</li></ul><a id="more"></a><h4 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h4><ol><li><p>list, set, map容器</p><ul><li>在使用 list、set 或 map遍历删除某些元素时可以这样使用：</li><li><p>正确写法1：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itList;</span><br><span class="line"><span class="keyword">for</span> (itList = List.begin(); itList != List.end(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (WillDelete(*itList)) &#123;</span><br><span class="line">         itList = List.erase(itList);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         itList++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正确写法2：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itList;</span><br><span class="line">   <span class="keyword">for</span> (itList = List.begin(); itList != List.end(); ) &#123;</span><br><span class="line">       <span class="keyword">if</span> (WillDelete( *itList)) &#123;</span><br><span class="line">           List.erase(itList++);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           itList++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>错误写法1：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itList;</span><br><span class="line">      <span class="keyword">for</span> (itList = List.begin(); itList != List.end(); itList++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (WillDelete(*itList)) &#123;</span><br><span class="line">              List.erase(itList);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>错误写法2：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator itList;</span><br><span class="line">      <span class="keyword">for</span> (itList = List.begin(); itList != List.end(); ) &#123;</span><br><span class="line">          <span class="keyword">if</span> (WillDelete(*itList)) &#123;</span><br><span class="line">              itList = List.erase(++itList);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               itList++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>分析：</p><ol><li>正确使用方法1：通过erase方法的返回值来获取下一个元素的位置</li><li>正确使用方法2：在调用erase方法之前先使用 “++” 来获取下一个元素的位置</li><li>错误使用方法1：在调用erase方法之后使用 “++” 来获取下一个元素的位置，由于在调用erase方法以后，该元素的位置已经被删除，如果在根据这个旧的位置来获取下一个位置，则会出现异常。</li><li>错误使用方法2：同错误使用方法1</li></ol></li></ul></li><li><p>vector, deque容器</p><ul><li>在使用 vector、deque遍历删除元素时，也可以通过erase的返回值来获取下一个元素的位置</li><li><p>正确写法：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Vec;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itVec;</span><br><span class="line">      <span class="keyword">for</span>(itVec = Vec.begin(); itVec != Vec.end(); ) &#123;</span><br><span class="line">          <span class="keyword">if</span>(WillDelete( *itVec) ) &#123;</span><br><span class="line">              itVec = Vec.erase(itVec);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              itList++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意：</strong></p><ol><li><p>vector、deque 不能像上面的<code>正确使用方法2</code>的办法来遍历删除</p><ol><li>对于关联容器(如map, set, multimap,multiset)，删除当前的iterator，<strong>仅仅会使当前的iterator失效</strong>，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响</li><li>对于序列式容器(如vector,deque)，<strong>删除当前的iterator会使后面所有元素的iterator都失效</strong>。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。但是erase方法可以返回下一个有效的iterator</li><li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种方法都可以使用</li></ol></li></ol></li></ul></li></ol><h4 id="相关容器介绍"><a href="#相关容器介绍" class="headerlink" title="相关容器介绍"></a>相关容器介绍</h4><ol><li><p>vector</p><ul><li>内部数据结构：数组</li><li>访问：随机访问每个元素，所需要的时间为常量</li><li>增删元素：在末尾增加或删除元素所需时间与元素数目无关，在中间或开头增加或删除元素所需时间随元素数目呈线性变化</li><li>迭代器：vector的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。当把超过capacity()-size()个元素插入vector中时，内存会重新分配，所有的迭代器都将失效；否则，指向当前元素以后的任何元素的迭代器都将失效。当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效</li></ul></li><li><p>deque</p><ul><li>内部数据结构：数组</li><li>访问：随机访问每个元素，所需要的时间为常量</li><li>增删元素：在开头和末尾增加元素所需时间与元素数目无关，在中间增加或删除元素所需时间随元素数目呈线性变化</li><li>迭代器： 增加任何元素都将使deque的迭代器失效。在deque的中间删除元素将使迭代器失效。在deque的头或尾删除元素时，只有指向该元素的迭代器失效</li></ul></li><li><p>lsit</p><ul><li>内部数据结构：双向环状链表</li><li>访问：不能随机访问一个元素</li><li>增删元素：在开头、末尾和中间任何地方增加或删除元素所需时间都为常量</li><li>迭代器：增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效</li></ul></li><li><p>slist</p><ul><li>内部数据结构：单向链表</li><li>访问：不可双向遍历，只能从前到后地遍历</li><li>增删元素：在开头、末尾和中间任何地方增加或删除元素所需时间都为常量</li><li>迭代器：增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效</li></ul></li><li><p>stack</p><ul><li>内部数据结构：适配器，它可以将任意类型的序列容器转换为一个堆栈，一般使用deque作为支持的序列容器</li><li>访问：不能遍历整个stack</li><li>增删元素：元素只能后进先出</li></ul></li><li><p>queue</p><ul><li>内部数据结构：适配器，它可以将任意类型的序列容器转换为一个队列，一般使用deque作为支持的序列容器</li><li>访问：不能遍历整个queue</li><li>增删元素：元素只能先进先出</li></ul></li><li><p>priority_queue</p><ul><li>内部数据结构：适配器，它可以将任意类型的序列容器转换为一个优先级队列，一般使用vector作为底层存储方式</li><li>访问：只能访问第一个元素，不能遍历整个priority_queue</li><li>增删元素：第一个元素始终是优先级最高的一个元素</li></ul></li><li><p>set(hash_set不解释了)</p><ul><li>内部数据结构：红黑树</li><li>访问：随机访问</li><li>增删元素：键和值相等且键唯一</li><li>迭代器：如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效</li></ul></li><li><p>map(hash_map不解释了)</p><ul><li>内部数据结构：红黑树</li><li>访问：随机访问</li><li>增删元素：键唯一</li><li>迭代器：如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C++迭代器很好用，但是使用的时候一不留神就会出错，迭代器失效就是其中之一。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="语言" scheme="http://roux.top/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://roux.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++之POD类型</title>
    <link href="http://roux.top/2018/12/13/C++%E4%B9%8BPOD%E7%B1%BB%E5%9E%8B/"/>
    <id>http://roux.top/2018/12/13/C++之POD类型/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-18T10:57:56.051Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><p><code>POD(Plain Old Data)</code>是C++中非常重要的一个概念，用来描述一个类型的属性。其中<code>Plain</code>表示这个类型是个平凡的类型，<code>Old</code>表示其与C的兼容性(就意味着可以使用 memcpy() 函数进行操作)。</p></li><li><p>C++11中将POD划分为两个基本概念：<code>平凡的（trival）</code>和<code>标准布局（standardlayout）</code></p></li></ul><a id="more"></a><h4 id="平凡-trival"><a href="#平凡-trival" class="headerlink" title="平凡(trival)"></a>平凡(trival)</h4><ul><li>满足条件<ol><li><strong>不能写 <code>构造/析构函数</code>、<code>拷贝/移动构造函数</code>、<code>拷贝/移动赋值运算符</code></strong>，而是用编译器自动为我们生成，那这个数据就是“平凡的”。非要写的话，用 C++ 11 的 <code>default</code> 关键字。<ul><li>C++为我们提供了一个类模板来识别一个类是否平凡：<code>template &lt;typename T&gt; struct std::is_trival</code></li></ul></li><li><strong>不能有 <code>虚函数</code> 和 <code>虚基类</code></strong>。</li></ol></li></ul><h4 id="标准布局"><a href="#标准布局" class="headerlink" title="标准布局"></a>标准布局</h4><ul><li><p>满足条件</p><ol><li><strong>普通成员有相同的访问级别</strong></li><li><strong>第一个成员必须是自己的</strong>(也即类中第一个非静态成员的类型与其基类不同)</li><li><strong>只要有父类，普通成员只能在其中一个类中，不可分散</strong>(也即<code>派生类中有非静态成员，且只有一个仅包含静态成员的基类</code>或者<code>基类有非静态成员，而派生类没有非静态成员</code>)</li><li><strong>没有虚函数和虚基类</strong></li></ol><ul><li><p>C++提供了一个模板来判断一个类或者结构体是否是标准布局:<code>template &lt;typename T&gt; struct std::is_standard_layout; //头文件为&lt;type_traits&gt;</code></p></li><li><p>C++提供了一个模板来判断一个类或者结构体是否是POD:<code>template &lt;typename T&gt; struct std::is_pod //头文件为&lt;type_traits&gt;</code></p></li></ul></li></ul><h4 id="POD的好处"><a href="#POD的好处" class="headerlink" title="POD的好处"></a>POD的好处</h4><ol><li><p>字节赋值，我们可以放心的使用<code>memset</code>和<code>memcpy</code>对POD类型进行初始化和拷贝。</p></li><li><p>提供对C内存的兼容。POD类型的数据在C与C++间的操作总是安全的。</p></li><li><p>保证了静态初始化的安全有效。POD类型的对象初始化往往更简单</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;POD(Plain Old Data)&lt;/code&gt;是C++中非常重要的一个概念，用来描述一个类型的属性。其中&lt;code&gt;Plain&lt;/code&gt;表示这个类型是个平凡的类型，&lt;code&gt;Old&lt;/code&gt;表示其与C的兼容性(就意味着可以使用 memcpy() 函数进行操作)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C++11中将POD划分为两个基本概念：&lt;code&gt;平凡的（trival）&lt;/code&gt;和&lt;code&gt;标准布局（standardlayout）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="语言" scheme="http://roux.top/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://roux.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 严格弱序</title>
    <link href="http://roux.top/2018/12/13/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F/"/>
    <id>http://roux.top/2018/12/13/严格弱序/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-18T10:54:22.378Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>学习C++11遇到的重要的点。</li></ul><a id="more"></a><h4 id="什么是严格弱序"><a href="#什么是严格弱序" class="headerlink" title="什么是严格弱序"></a>什么是严格弱序</h4><ul><li><code>C++关联容器</code>的有序容器对元素关键字的类型有要求，元素关键字的类型必须定义了<code>严格序（stick weak ordering）</code> ，以内置类型来说，C++都定义了<code>“&lt;”</code>操作符，这就是一个严格弱序，而<code>“&lt;=”</code>就不是一个严格弱序</li></ul><h4 id="表示与作用"><a href="#表示与作用" class="headerlink" title="表示与作用"></a>表示与作用</h4><ul><li><p>a小于b：<code>a &lt; b</code></p></li><li><p>a大于b：<code>a &gt; b</code></p></li><li><p>a等于b：<code>!(a &lt; b) &amp;&amp; !(a &gt; b)</code></p></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>非自反性： 如果存在两个关键字，任何一个都不<code>严格弱序</code>于另一个，则这两个关键字是相等的，<code>即comp(a, a)必须是false</code></li><li>非对称性： 两个关键字不能同时<code>严格弱序</code>于对方，<code>即如果comp(a, b)和comp(b, a)的结果必然相反</code></li><li>传递性：如果a<code>严格弱序</code>于b，且b<code>严格弱序</code>于c，则a必须<code>严格弱序</code>于c，<code>即如果comp(a, b)为true，comp(b, c)为true，那么comp(a, c)必然为true</code></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>有序关联容器不允许存在相同的关键字，在用<code>compare函数</code>判断时，会认为相同的关键字是不相等的，因此会将两个相同的关键字插入容器中，这个行为是未定义的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;学习C++11遇到的重要的点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Others" scheme="http://roux.top/categories/Others/"/>
    
    
      <category term="C++" scheme="http://roux.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>不将就</title>
    <link href="http://roux.top/2018/10/24/%E4%B8%8D%E5%B0%86%E5%B0%B1/"/>
    <id>http://roux.top/2018/10/24/不将就/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2019-01-06T12:20:50.690Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;对最近的一段时间进行梳理。</p><a id="more"></a><p>&emsp;&emsp;自从实习结束并回到学校后，持续过了一个月的“闲人”生活，期间，中秋结束后和好基友<code>张越</code>完成了为期11天的旅游，欣赏了这个世界的美丽(当然包括小姐姐们，享受脸.jpg)，也享受了各种美食，很开心(很感谢我儿子一路上的规划，简直完美）。<br>&emsp;&emsp;国庆节后，开始阅读技术书籍，同时参与一些分享活动。期间，身边人找工作也都陆续结束，各种玩耍，各种皮。关于女朋友这事也被提及的越来越多，自己也想了想，的确是在很多难过或者困难的时候，有个人在一起陪伴或者安慰都是极棒的，这也导致我曾经一度想找个先这样。不过对自己生活的不满意，对自己要求的提升，让我觉得这算是对生活的一种妥协，我还年轻，还有机会去尝试，所以不能轻易妥协。<br>&emsp;&emsp;现在，努力提升自己，让自己过得精致一点，多多投资自己，保持一种态度：对生活，不将就！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;对最近的一段时间进行梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://roux.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://roux.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>实习总结</title>
    <link href="http://roux.top/2018/08/31/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://roux.top/2018/08/31/实习总结/</id>
    <published>2018-08-30T16:00:00.000Z</published>
    <updated>2018-10-25T08:59:32.717Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;work hard， work smart！<br><a id="more"></a></p><p>&emsp;&emsp;不知不觉三个月的实习就结束了，也许只有到最后要走的时候才会真正的感受到一些别样的情绪充斥在心间。感谢这段时间师兄师姐们的指导与帮助，也很开心能够遇见这么多的小伙伴！<br>&emsp;&emsp;最终得知转正的结果还是很开心的，后面呢，也准备留在阿里了。以这段时间的感受来说：阿里是一家很有责任感的公司、公司内部的腐败程度个人感觉还是较其他公司好的、阿里的价值观我表示认同、最主要的是身边的小伙伴们都很nice。感觉这里面的环境很适合我，个人也比较懒，也就不想再换公司了（换公司的话，这种环境很难说）<br>&emsp;&emsp;实习期间学到的东西还是很多的，主要是开了眼界，思想上有了相应的提升，对大公司的流程什么的都有了了解，而且对自己后面的方向也能够做出一些选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;work hard， work smart！&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://roux.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://roux.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Vmware的一些问题</title>
    <link href="http://roux.top/2018/05/10/Vmware%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://roux.top/2018/05/10/Vmware的一些问题/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-18T08:40:15.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>前几天换了个电脑，于是所有的东西都需要拷贝和重装，在装vmware的时候遇到了一些问题，所以记录在这里。</li></ul><a id="more"></a><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><p>windows7</p><ul><li>可以安装任何的版本，而且安装所有的系统都是没问题的。要注意的就是对vmware的服务要保持开启，给centos7安装vmtools的时候有点麻烦。这里注意的没有什么太多。</li></ul></li><li><p>windows10</p><ul><li><p>这里的话在安装vmware的时候需要安装vmware12及以上的版本，官方给的说明是11的时候就开始支持windows10了，但是我在装ubuntu16.04的时候直接报错导致安装失败，之后我使用12版本的直接成功。在这里需要注意的是在装系统的时候需要把硬件定制里面的显示的3D图形加速关闭，否则会出现黑屏的现象。如果ubuntu出现屏幕分辨率的问题导致无法点击安装过程中的确认或者下一步按钮的情况，可以先试用，然后选择设置修改分辨率，让其适合当前的分辨率，然后再次进入就可以看到和选择了。</p></li><li><p>由于中间有一次直接用杀毒软件结束掉了VMware，导致我在下一次打开ubuntu的时候显示正在使用中，用了其他的一些方法也都没解决，最终找到一个方法简单粗暴：找到安装操作系统的目录，进去后会看到两个后缀为<code>.lck</code>的文件夹，把这两个文件夹剪切出来（删除掉也可以，你打开以后会重建），然后再打开虚拟机就没问题了。具体的原因还没去了解。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;前几天换了个电脑，于是所有的东西都需要拷贝和重装，在装vmware的时候遇到了一些问题，所以记录在这里。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://roux.top/categories/Tools/"/>
    
    
      <category term="VMware" scheme="http://roux.top/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析的过程</title>
    <link href="http://roux.top/2018/04/22/DNS%E8%A7%A3%E6%9E%90/"/>
    <id>http://roux.top/2018/04/22/DNS解析/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-04-22T06:26:43.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>对于网络这一块，有太多的学问，而且这个也是后面重点需要优化的方向，所以最近会写一些这方面的文章。</li></ul><a id="more"></a><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>在浏览器中输入<a href="http://www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。" target="_blank" rel="noopener">www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</a> </li><li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </li><li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </li><li>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 </li><li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com主机。" target="_blank" rel="noopener">www.qq.com主机。</a> </li><li>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 </li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>人们在 DNS 中发现了一些漏洞，攻击者可以利用这些漏洞劫持这一使用名称在 互联网 上搜寻某个人或某个站点的过程。这种攻击的目的是取得对会话的控制以实施某种操作，例如使用户进入劫持者自己设立的欺骗性网站，以便收集用户的帐户和密码。</p></li><li><p>安全的DNS—<a href="https://www.icann.org/resources/pages/dnssec-qaa-2014-01-29-zh" target="_blank" rel="noopener">DNSSEC</a></p></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.nowcoder.com/profile/2286733/myFollowings/detail/4794271" target="_blank" rel="noopener">https://www.nowcoder.com/profile/2286733/myFollowings/detail/4794271</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对于网络这一块，有太多的学问，而且这个也是后面重点需要优化的方向，所以最近会写一些这方面的文章。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Protocol" scheme="http://roux.top/categories/Protocol/"/>
    
    
      <category term="DNS" scheme="http://roux.top/tags/DNS/"/>
    
  </entry>
  
</feed>
